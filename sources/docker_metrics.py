"""
Docker Metrics Collection and Visualization

Real-time metrics with circular buffers and ASCII trend charts.
Generated by GitHub Copilot - Inspired by lazydocker metrics system
"""

import collections
import time
from typing import Optional, Dict, List, Deque
from dataclasses import dataclass, field
import json


@dataclass
class ContainerMetrics:
    """Metrics for a single container"""
    container_id: str
    cpu_percent: float = 0.0
    memory_usage: int = 0  # in bytes
    memory_limit: int = 0  # in bytes
    network_rx: int = 0    # in bytes
    network_tx: int = 0    # in bytes
    pids_running: int = 0
    timestamp: float = field(default_factory=time.time)
    
    @property
    def memory_percent(self) -> float:
        """Memory usage as percentage"""
        if self.memory_limit == 0:
            return 0.0
        return (self.memory_usage / self.memory_limit) * 100


class MetricsBuffer:
    """Circular buffer for container metrics time series"""
    
    def __init__(self, max_size: int = 100):
        self.max_size = max_size
        self.cpu_history: Deque[float] = collections.deque(maxlen=max_size)
        self.memory_history: Deque[float] = collections.deque(maxlen=max_size)
        self.network_rx_history: Deque[int] = collections.deque(maxlen=max_size)
        self.network_tx_history: Deque[int] = collections.deque(maxlen=max_size)
        self.pids_history: Deque[int] = collections.deque(maxlen=max_size)
        self.timestamps: Deque[float] = collections.deque(maxlen=max_size)
    
    def add_point(self, cpu: float, memory: float, rx: int, tx: int, pids: int) -> None:
        """Add new metrics point"""
        self.cpu_history.append(cpu)
        self.memory_history.append(memory)
        self.network_rx_history.append(rx)
        self.network_tx_history.append(tx)
        self.pids_history.append(pids)
        self.timestamps.append(time.time())
    
    def get_trend_symbols(self, metric: str = "cpu") -> str:
        """
        Return ASCII trend visualization.
        
        Example: ▁▂▃▄▅▆▇█
        """
        hist = self._get_history(metric)
        if not hist:
            return "▁"
        
        max_val = max(hist) if hist else 1.0
        if max_val == 0:
            max_val = 1.0
        
        symbols = ["▁", "▂", "▃", "▄", "▅", "▆", "▇", "█"]
        
        # Show last 12 points
        trend = "".join(
            symbols[min(int(v / max_val * 7), 7)]
            for v in list(hist)[-12:]
        )
        return trend
    
    def get_mini_graph(self, metric: str = "cpu", width: int = 20, height: int = 5) -> str:
        """
        Generate a mini ASCII graph.
        
        Example:
            █     ▄
            █ ▂ ▄ █
            █▂██▂█████
        """
        hist = self._get_history(metric)
        if not hist or len(hist) < 2:
            return ""
        
        max_val = max(hist) or 1.0
        
        # Normalize to height range (1-height)
        normalized = [
            max(1, int((v / max_val) * (height - 1)) + 1)
            for v in list(hist)[-width:]
        ]
        
        # Build graph from top to bottom
        lines = []
        for row in range(height, 0, -1):
            line = ""
            for val in normalized:
                if val >= row:
                    line += "█"
                else:
                    line += " "
            lines.append(line.rstrip())
        
        return "\n".join(lines)
    
    def get_stats(self, metric: str = "cpu") -> Dict[str, float]:
        """Get statistics for metric"""
        hist = self._get_history(metric)
        if not hist:
            return {"min": 0, "max": 0, "avg": 0, "latest": 0}
        
        return {
            "min": min(hist),
            "max": max(hist),
            "avg": sum(hist) / len(hist),
            "latest": hist[-1] if hist else 0
        }
    
    def _get_history(self, metric: str) -> Optional[Deque]:
        """Get history deque for metric"""
        metric_map = {
            "cpu": self.cpu_history,
            "memory": self.memory_history,
            "rx": self.network_rx_history,
            "tx": self.network_tx_history,
            "pids": self.pids_history,
        }
        return metric_map.get(metric)


class MetricsCollector:
    """Collect and store metrics for containers"""
    
    def __init__(self, max_container_history: int = 100):
        self.containers: Dict[str, MetricsBuffer] = {}
        self.max_container_history = max_container_history
    
    def add_metrics(self, container_id: str, metrics: ContainerMetrics) -> None:
        """Add metrics for container"""
        if container_id not in self.containers:
            self.containers[container_id] = MetricsBuffer(self.max_container_history)
        
        buffer = self.containers[container_id]
        buffer.add_point(
            cpu=metrics.cpu_percent,
            memory=metrics.memory_percent,
            rx=metrics.network_rx,
            tx=metrics.network_tx,
            pids=metrics.pids_running
        )
    
    def get_buffer(self, container_id: str) -> Optional[MetricsBuffer]:
        """Get metrics buffer for container"""
        return self.containers.get(container_id)
    
    def clear_container(self, container_id: str) -> None:
        """Clear metrics for container (when stopped/removed)"""
        if container_id in self.containers:
            del self.containers[container_id]
    
    def get_top_cpu_consumers(self, limit: int = 5) -> List[tuple[str, float]]:
        """Get containers with highest CPU usage"""
        consumers = []
        for container_id, buffer in self.containers.items():
            if buffer.cpu_history:
                latest_cpu = buffer.cpu_history[-1]
                consumers.append((container_id, latest_cpu))
        
        return sorted(consumers, key=lambda x: x[1], reverse=True)[:limit]
    
    def get_top_memory_consumers(self, limit: int = 5) -> List[tuple[str, float]]:
        """Get containers with highest memory usage"""
        consumers = []
        for container_id, buffer in self.containers.items():
            if buffer.memory_history:
                latest_memory = buffer.memory_history[-1]
                consumers.append((container_id, latest_memory))
        
        return sorted(consumers, key=lambda x: x[1], reverse=True)[:limit]


class MetricsFormatter:
    """Format metrics for display"""
    
    @staticmethod
    def format_memory(bytes_val: int) -> str:
        """Format bytes as human readable"""
        value = float(bytes_val)
        for unit in ['B', 'KB', 'MB', 'GB']:
            if value < 1024:
                return f"{value:.1f}{unit}"
            value /= 1024
        return f"{value:.1f}TB"
    
    @staticmethod
    def format_percentage(value: float) -> str:
        """Format percentage with color indicator"""
        if value < 25:
            return f"{value:.1f}%"
        elif value < 50:
            return f"{value:.1f}%"
        elif value < 75:
            return f"{value:.1f}%"
        else:
            return f"{value:.1f}% ⚠"
    
    @staticmethod
    def format_bandwidth(bytes_per_sec: int) -> str:
        """Format network bandwidth"""
        value = float(bytes_per_sec)
        for unit in ['B/s', 'KB/s', 'MB/s', 'GB/s']:
            if value < 1024:
                return f"{value:.1f}{unit}"
            value /= 1024
        return f"{value:.1f}TB/s"
    
    @staticmethod
    def format_metrics_line(container_name: str, metrics: ContainerMetrics) -> str:
        """Format single metrics line"""
        cpu_str = f"{metrics.cpu_percent:6.1f}%"
        mem_str = MetricsFormatter.format_memory(metrics.memory_usage).rjust(10)
        mem_pct = f"{metrics.memory_percent:5.1f}%"
        pids_str = f"{metrics.pids_running:3d}"
        
        return f"{container_name:20s} CPU:{cpu_str}  MEM:{mem_str} ({mem_pct})  PIDs:{pids_str}"


class SystemMetrics:
    """Collect system-wide Docker metrics"""
    
    def __init__(self):
        self.container_count: Deque[int] = collections.deque(maxlen=100)
        self.image_count: Deque[int] = collections.deque(maxlen=100)
        self.total_size: Deque[int] = collections.deque(maxlen=100)
        self.timestamps: Deque[float] = collections.deque(maxlen=100)
    
    def add_snapshot(self, container_count: int, image_count: int, 
                     total_size_bytes: int) -> None:
        """Add system metrics snapshot"""
        self.container_count.append(container_count)
        self.image_count.append(image_count)
        self.total_size.append(total_size_bytes)
        self.timestamps.append(time.time())
    
    def get_latest(self) -> Optional[Dict]:
        """Get latest system metrics"""
        if not self.container_count:
            return None
        
        return {
            "containers": self.container_count[-1],
            "images": self.image_count[-1],
            "total_size": self.total_size[-1],
            "timestamp": self.timestamps[-1]
        }
