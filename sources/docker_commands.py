"""
Docker Commands Module

Organized command interfaces for Docker operations.
Generated by GitHub Copilot - Inspired by lazydocker architecture
"""

import asyncio
import json
from typing import List, Dict, Optional, Union
from dataclasses import dataclass, field
import time

from docker_network import CommandExecutor


@dataclass
class CommandResult:
    """Result from a Docker command"""
    success: bool
    output: str
    error: str = ""
    returncode: int = 0
    timestamp: float = field(default_factory=time.time)


class ContainerCommands:
    """All container operations in one organized interface"""
    
    def __init__(self, executor: CommandExecutor):
        self.executor = executor
    
    async def get_all(self, filters: Optional[Dict] = None) -> List[Dict]:
        """Get all containers with optional filters"""
        cmd = ["docker", "ps", "-a", "--format", "json"]
        
        if filters:
            for key, value in filters.items():
                cmd.extend(["--filter", f"{key}={value}"])
        
        try:
            output = await self.executor.run(cmd)
            if not output.strip():
                return []
            return json.loads(f"[{','.join(output.strip().split(chr(10)))}]")
        except (json.JSONDecodeError, Exception):
            return []
    
    async def get_by_id(self, container_id: str) -> Optional[Dict]:
        """Get container by ID"""
        containers = await self.get_all(filters={"id": container_id})
        return containers[0] if containers else None
    
    async def start(self, container_id: str) -> CommandResult:
        """Start a container"""
        try:
            output = await self.executor.run(["docker", "start", container_id])
            return CommandResult(success=True, output=output)
        except Exception as e:
            return CommandResult(success=False, output="", error=str(e), returncode=1)
    
    async def stop(self, container_id: str, timeout: int = 10) -> CommandResult:
        """Stop a container"""
        try:
            output = await self.executor.run([
                "docker", "stop", "-t", str(timeout), container_id
            ])
            return CommandResult(success=True, output=output)
        except Exception as e:
            return CommandResult(success=False, output="", error=str(e), returncode=1)
    
    async def restart(self, container_id: str, timeout: int = 10) -> CommandResult:
        """Restart a container"""
        try:
            output = await self.executor.run([
                "docker", "restart", "-t", str(timeout), container_id
            ])
            return CommandResult(success=True, output=output)
        except Exception as e:
            return CommandResult(success=False, output="", error=str(e), returncode=1)
    
    async def pause(self, container_id: str) -> CommandResult:
        """Pause a container"""
        try:
            output = await self.executor.run(["docker", "pause", container_id])
            return CommandResult(success=True, output=output)
        except Exception as e:
            return CommandResult(success=False, output="", error=str(e), returncode=1)
    
    async def unpause(self, container_id: str) -> CommandResult:
        """Unpause a container"""
        try:
            output = await self.executor.run(["docker", "unpause", container_id])
            return CommandResult(success=True, output=output)
        except Exception as e:
            return CommandResult(success=False, output="", error=str(e), returncode=1)
    
    async def remove(self, container_id: str, force: bool = False) -> CommandResult:
        """Remove a container"""
        cmd = ["docker", "rm"]
        if force:
            cmd.append("-f")
        cmd.append(container_id)
        
        try:
            output = await self.executor.run(cmd)
            return CommandResult(success=True, output=output)
        except Exception as e:
            return CommandResult(success=False, output="", error=str(e), returncode=1)
    
    async def get_logs(self, container_id: str, tail: int = 100, 
                       follow: bool = False) -> str:
        """Get container logs"""
        cmd = ["docker", "logs", f"--tail={tail}"]
        if follow:
            cmd.append("--follow")
        cmd.extend(["--timestamps", container_id])
        
        try:
            return await self.executor.run(cmd)
        except Exception:
            return ""
    
    async def inspect(self, container_id: str) -> Optional[Dict]:
        """Get detailed container information"""
        try:
            output = await self.executor.run(["docker", "inspect", container_id])
            data = json.loads(output)
            return data[0] if data else None
        except Exception:
            return None
    
    async def get_stats(self, container_id: str) -> Optional[Dict]:
        """Get container statistics"""
        try:
            output = await self.executor.run([
                "docker", "stats", container_id, "--no-stream", "--format", "json"
            ])
            return json.loads(output) if output.strip() else None
        except Exception:
            return None
    
    async def prune(self, filters: Optional[List[str]] = None) -> CommandResult:
        """Prune stopped containers"""
        cmd = ["docker", "container", "prune", "-f"]
        
        if filters:
            for f in filters:
                cmd.extend(["--filter", f])
        
        try:
            output = await self.executor.run(cmd)
            return CommandResult(success=True, output=output)
        except Exception as e:
            return CommandResult(success=False, output="", error=str(e), returncode=1)


class ImageCommands:
    """All image operations"""
    
    def __init__(self, executor: CommandExecutor):
        self.executor = executor
    
    async def get_all(self) -> List[Dict]:
        """Get all images"""
        try:
            output = await self.executor.run([
                "docker", "images", "--format", "json"
            ])
            if not output.strip():
                return []
            return json.loads(f"[{','.join(output.strip().split(chr(10)))}]")
        except (json.JSONDecodeError, Exception):
            return []
    
    async def get_by_id(self, image_id: str) -> Optional[Dict]:
        """Get image by ID or name"""
        images = await self.get_all()
        for img in images:
            if img.get("ID", "").startswith(image_id) or img.get("Repository") == image_id:
                return img
        return None
    
    async def inspect(self, image_id: str) -> Optional[Dict]:
        """Get detailed image information"""
        try:
            output = await self.executor.run(["docker", "inspect", image_id])
            data = json.loads(output)
            return data[0] if data else None
        except Exception:
            return None
    
    async def remove(self, image_id: str, force: bool = False) -> CommandResult:
        """Remove an image"""
        cmd = ["docker", "rmi"]
        if force:
            cmd.append("-f")
        cmd.append(image_id)
        
        try:
            output = await self.executor.run(cmd)
            return CommandResult(success=True, output=output)
        except Exception as e:
            return CommandResult(success=False, output="", error=str(e), returncode=1)
    
    async def prune(self, dangling_only: bool = False) -> CommandResult:
        """Prune unused images"""
        cmd = ["docker", "image", "prune", "-f"]
        if dangling_only:
            cmd.append("-a")
        
        try:
            output = await self.executor.run(cmd)
            return CommandResult(success=True, output=output)
        except Exception as e:
            return CommandResult(success=False, output="", error=str(e), returncode=1)


class NetworkCommands:
    """Network operations"""
    
    def __init__(self, executor: CommandExecutor):
        self.executor = executor
    
    async def get_all(self) -> List[Dict]:
        """Get all networks"""
        try:
            output = await self.executor.run([
                "docker", "network", "ls", "--format", "json"
            ])
            if not output.strip():
                return []
            return json.loads(f"[{','.join(output.strip().split(chr(10)))}]")
        except (json.JSONDecodeError, Exception):
            return []
    
    async def inspect(self, network_id: str) -> Optional[Dict]:
        """Inspect network"""
        try:
            output = await self.executor.run([
                "docker", "network", "inspect", network_id
            ])
            data = json.loads(output)
            return data[0] if data else None
        except Exception:
            return None
    
    async def get_connected_containers(self, network_id: str) -> List[str]:
        """Get containers connected to network"""
        try:
            info = await self.inspect(network_id)
            if info and "Containers" in info:
                return list(info["Containers"].keys())
            return []
        except Exception:
            return []


class VolumeCommands:
    """Volume operations"""
    
    def __init__(self, executor: CommandExecutor):
        self.executor = executor
    
    async def get_all(self) -> List[Dict]:
        """Get all volumes"""
        try:
            output = await self.executor.run([
                "docker", "volume", "ls", "--format", "json"
            ])
            if not output.strip():
                return []
            return json.loads(f"[{','.join(output.strip().split(chr(10)))}]")
        except (json.JSONDecodeError, Exception):
            return []
    
    async def inspect(self, volume_name: str) -> Optional[Dict]:
        """Inspect volume"""
        try:
            output = await self.executor.run([
                "docker", "volume", "inspect", volume_name
            ])
            data = json.loads(output)
            return data[0] if data else None
        except Exception:
            return None
    
    async def remove(self, volume_name: str) -> CommandResult:
        """Remove volume"""
        try:
            output = await self.executor.run([
                "docker", "volume", "rm", volume_name
            ])
            return CommandResult(success=True, output=output)
        except Exception as e:
            return CommandResult(success=False, output="", error=str(e), returncode=1)
    
    async def prune(self) -> CommandResult:
        """Prune unused volumes"""
        try:
            output = await self.executor.run([
                "docker", "volume", "prune", "-f"
            ])
            return CommandResult(success=True, output=output)
        except Exception as e:
            return CommandResult(success=False, output="", error=str(e), returncode=1)


class SystemCommands:
    """System-wide operations"""
    
    def __init__(self, executor: CommandExecutor):
        self.executor = executor
    
    async def get_info(self) -> Optional[Dict]:
        """Get Docker system info"""
        try:
            output = await self.executor.run(["docker", "info", "--format", "json"])
            return json.loads(output) if output.strip() else None
        except Exception:
            return None
    
    async def get_disk_usage(self) -> Optional[Dict]:
        """Get Docker disk usage"""
        try:
            output = await self.executor.run([
                "docker", "system", "df", "--format", "json"
            ])
            return json.loads(output) if output.strip() else None
        except Exception:
            return None
    
    async def prune_all(self, volumes: bool = False) -> CommandResult:
        """Prune all unused Docker resources"""
        cmd = ["docker", "system", "prune", "-f"]
        if volumes:
            cmd.append("--volumes")
        
        try:
            output = await self.executor.run(cmd)
            return CommandResult(success=True, output=output)
        except Exception as e:
            return CommandResult(success=False, output="", error=str(e), returncode=1)
