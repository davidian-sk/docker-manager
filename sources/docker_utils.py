#!/usr/bin/env python3
"""
Docker Monitor - Docker-specific utilities and command extraction
Author: David Smidke - Accenture
Generated by GitHub Copilot

Advanced Docker operations: command reconstruction, inspect parsing, image analysis.
"""

import asyncio
import json
import logging
import re
from typing import Dict, List, Optional, Tuple, Any, Callable
from docker_models import DockerRunCommand


class DockerCommandExtractor:
    """Extract and reconstruct docker run commands from running containers - Generated by GitHub Copilot"""
    
    def __init__(self, timeout: int = 10):
        self._timeout = timeout
        self._log = logging.getLogger(__name__)
    
    async def run_cmd(self, cmd: List[str]) -> str:
        """Execute command asynchronously with timeout - Generated by GitHub Copilot
        
        Security: Subprocess killed on timeout to prevent orphaned processes.
        """
        proc = None
        try:
            proc = await asyncio.create_subprocess_exec(
                *cmd, 
                stdout=asyncio.subprocess.PIPE, 
                stderr=asyncio.subprocess.PIPE
            )
            stdout, stderr = await asyncio.wait_for(proc.communicate(), timeout=self._timeout)
            return stdout.decode('utf-8', errors='ignore')
        except asyncio.TimeoutError:
            if proc is not None:
                try:
                    proc.kill()
                    await proc.wait()
                except ProcessLookupError:
                    pass
            self._log.debug(f"Command timed out: {' '.join(cmd)}")
        except Exception as e:
            self._log.debug(f"Error running command: {e}")
        return ""
    
    async def extract_run_command(self, container_id: str) -> Optional[DockerRunCommand]:
        """
        Extract docker run command from container inspect
        
        Generated by GitHub Copilot - Security: Input validation on container_id
        """
        # Validate container_id format (hex string, at least 12 chars)
        if not re.match(r'^[a-f0-9]{12,}$', container_id):
            return None
        
        try:
            inspect_output = await self.run_cmd(["docker", "inspect", container_id])
            if not inspect_output:
                return None
            
            inspect_data = json.loads(inspect_output)[0]
            
            # Extract key information
            image = inspect_data.get('Config', {}).get('Image', '')
            ports = self._extract_ports(inspect_data)
            volumes = self._extract_volumes(inspect_data)
            env_vars = self._extract_env_vars(inspect_data)
            networks = self._extract_networks(inspect_data)
            
            # Reconstruct the run command
            command_parts = ["docker", "run"]
            
            # Add port mappings
            for port_mapping in ports:
                command_parts.extend(["-p", port_mapping])
            
            # Add volume mappings
            for volume in volumes:
                command_parts.extend(["-v", volume])
            
            # Add environment variables
            for k, v in env_vars.items():
                command_parts.extend(["-e", f"{k}={v}"])
            
            # Add networks
            for network in networks:
                command_parts.extend(["--network", network])
            
            # Add container name
            name = inspect_data.get('Name', '').lstrip('/')
            if name:
                command_parts.extend(["--name", name])
            
            # Add image and command
            command_parts.append(image)
            cmd_list = inspect_data.get('Config', {}).get('Cmd', [])
            if cmd_list:
                command_parts.extend(cmd_list)
            
            command_str = " ".join(command_parts)
            
            return DockerRunCommand(
                container_id=container_id,
                command=command_str,
                ports=ports,
                volumes=volumes,
                environment_vars=env_vars,
                image=image,
                networks=networks
            )
        except Exception as e:
            self._log.debug(f"Failed to extract run command: {e}")
            return None
    
    @staticmethod
    def _extract_ports(inspect_data: Dict) -> List[str]:
        """Extract port mappings"""
        ports = []
        port_bindings = inspect_data.get('HostConfig', {}).get('PortBindings', {})
        
        for container_port, host_bindings in port_bindings.items():
            if host_bindings:
                for binding in host_bindings:
                    host_ip = binding.get('HostIp', '')
                    host_port = binding.get('HostPort', '')
                    if host_port:
                        if host_ip and host_ip != '0.0.0.0':
                            ports.append(f"{host_ip}:{host_port}:{container_port}")
                        else:
                            ports.append(f"{host_port}:{container_port}")
            else:
                ports.append(f"{container_port}")
        
        return ports
    
    @staticmethod
    def _extract_volumes(inspect_data: Dict) -> List[str]:
        """Extract volume mappings"""
        volumes = []
        mounts = inspect_data.get('Mounts', [])
        
        for mount in mounts:
            if mount.get('Type') == 'bind':
                source = mount.get('Source', '')
                destination = mount.get('Destination', '')
                read_only = mount.get('RW', True)
                
                if source and destination:
                    vol_str = f"{source}:{destination}"
                    if not read_only:
                        vol_str += ":ro"
                    volumes.append(vol_str)
        
        return volumes
    
    @staticmethod
    def _extract_env_vars(inspect_data: Dict) -> Dict[str, str]:
        """Extract environment variables"""
        env_vars = {}
        env_list = inspect_data.get('Config', {}).get('Env', [])
        
        for env_str in env_list:
            if '=' in env_str:
                k, v = env_str.split('=', 1)
                env_vars[k] = v
        
        return env_vars
    
    @staticmethod
    def _extract_networks(inspect_data: Dict) -> List[str]:
        """Extract connected networks"""
        networks = []
        network_settings = inspect_data.get('NetworkSettings', {}).get('Networks', {})
        
        for network_name in network_settings.keys():
            if network_name != 'default':
                networks.append(network_name)
        
        return networks


class DockerImageAnalyzer:
    """Analyze Docker images for vulnerabilities and updates - Generated by GitHub Copilot"""
    
    def __init__(self, timeout: int = 10):
        self._timeout = timeout
        self._log = logging.getLogger(__name__)
    
    async def run_cmd(self, cmd: List[str]) -> str:
        """Execute command asynchronously - Generated by GitHub Copilot
        
        Security: Subprocess killed on timeout to prevent orphaned processes.
        """
        proc = None
        try:
            proc = await asyncio.create_subprocess_exec(
                *cmd,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            stdout, _ = await asyncio.wait_for(proc.communicate(), timeout=self._timeout)
            return stdout.decode('utf-8', errors='ignore')
        except asyncio.TimeoutError:
            if proc is not None:
                try:
                    proc.kill()
                    await proc.wait()
                except ProcessLookupError:
                    pass
            self._log.debug(f"Command timed out: {' '.join(cmd)}")
        except Exception as e:
            self._log.debug(f"Error running command: {e}")
        return ""
    
    async def get_image_history(self, image_id: str) -> List[str]:
        """Get image build history"""
        history_output = await self.run_cmd(["docker", "history", "--no-trunc", image_id])
        lines = []
        for line in history_output.splitlines()[1:]:  # Skip header
            if line.strip():
                lines.append(line)
        return lines[:10]  # Return last 10 layers
    
    async def get_image_digest(self, image_name: str) -> Optional[str]:
        """Get image digest for comparison"""
        inspect_output = await self.run_cmd(["docker", "inspect", image_name])
        if not inspect_output:
            return None
        
        try:
            data = json.loads(inspect_output)
            if data:
                return data[0].get('RepoDigests', [None])[0]
        except Exception:
            pass
        return None


class DockerHealthChecker:
    """Check Docker daemon health and system resources - Generated by GitHub Copilot"""
    
    def __init__(self, timeout: int = 5):
        self._timeout = timeout
        self._log = logging.getLogger(__name__)
    
    async def run_cmd(self, cmd: List[str]) -> Tuple[bool, str]:
        """Execute command and return success status - Generated by GitHub Copilot
        
        Security: Subprocess killed on timeout to prevent orphaned processes.
        """
        proc = None
        try:
            proc = await asyncio.create_subprocess_exec(
                *cmd,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            stdout, stderr = await asyncio.wait_for(proc.communicate(), timeout=self._timeout)
            success = proc.returncode == 0
            output = stdout.decode('utf-8', errors='ignore')
            return success, output
        except asyncio.TimeoutError:
            if proc is not None:
                try:
                    proc.kill()
                    await proc.wait()
                except ProcessLookupError:
                    pass
            return False, "Command timed out"
        except Exception as e:
            return False, str(e)
    
    async def check_docker_daemon(self) -> Tuple[bool, str]:
        """Check if Docker daemon is responsive"""
        success, output = await self.run_cmd(["docker", "version"])
        if success:
            return True, "Docker daemon is healthy"
        return False, f"Docker daemon error: {output}"
    
    async def get_disk_usage(self) -> Dict[str, Any]:
        """Get Docker disk usage statistics - Generated by GitHub Copilot"""
        success, output = await self.run_cmd(["docker", "system", "df"])
        
        if not success:
            return {}
        
        usage_data = {
            'images': 0,
            'containers': 0,
            'volumes': 0,
            'total_reclaimable': '0B'
        }
        
        for line in output.splitlines():
            if line.startswith('Images'):
                parts = line.split()
                if len(parts) >= 2:
                    usage_data['images'] = int(parts[1])
            elif line.startswith('Containers'):
                parts = line.split()
                if len(parts) >= 2:
                    usage_data['containers'] = int(parts[1])
            elif line.startswith('Local Volumes'):
                parts = line.split()
                if len(parts) >= 2:
                    usage_data['volumes'] = int(parts[2])
            elif line.startswith('TOTAL'):
                parts = line.split()
                if len(parts) >= 5:
                    usage_data['total_reclaimable'] = parts[4]
        
        return usage_data


class DockerNetworkInspector:
    """Inspect Docker networks and connectivity - Generated by GitHub Copilot"""
    
    def __init__(self, timeout: int = 5):
        self._timeout = timeout
        self._log = logging.getLogger(__name__)
    
    async def run_cmd(self, cmd: List[str]) -> str:
        """Execute command asynchronously - Generated by GitHub Copilot
        
        Security: Subprocess killed on timeout to prevent orphaned processes.
        """
        proc = None
        try:
            proc = await asyncio.create_subprocess_exec(
                *cmd,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            stdout, _ = await asyncio.wait_for(proc.communicate(), timeout=self._timeout)
            return stdout.decode('utf-8', errors='ignore')
        except asyncio.TimeoutError:
            if proc is not None:
                try:
                    proc.kill()
                    await proc.wait()
                except ProcessLookupError:
                    pass
            self._log.debug(f"Command timed out: {' '.join(cmd)}")
        except Exception as e:
            self._log.debug(f"Error: {e}")
        return ""
    
    async def get_network_list(self) -> List[Dict[str, str]]:
        """Get list of Docker networks"""
        networks_output = await self.run_cmd(["docker", "network", "ls", "--format", "{{.Name}}|{{.Driver}}|{{.Scope}}"])
        
        networks = []
        for line in networks_output.splitlines():
            parts = line.split('|')
            if len(parts) >= 3:
                networks.append({
                    'name': parts[0],
                    'driver': parts[1],
                    'scope': parts[2]
                })
        
        return networks

class DockerCommandError(Exception):
    """Docker command specific error - Generated by GitHub Copilot"""
    
    def __init__(self, cmd: str, stderr: str, returncode: int):
        self.cmd = cmd
        self.stderr = stderr
        self.returncode = returncode
        super().__init__(f"Docker error: {stderr}")
    
    @property
    def user_friendly_message(self) -> str:
        """Convert to user-friendly message"""
        stderr_lower = self.stderr.lower()
        
        if "permission denied" in stderr_lower:
            return "❌ Permission denied - user not in docker group. Run: sudo usermod -aG docker $USER"
        elif "not found" in stderr_lower:
            return "❌ Container/image not found"
        elif "already in use" in stderr_lower:
            return "❌ Port/name already in use by another container"
        elif "connection refused" in stderr_lower or "cannot connect" in stderr_lower:
            return "❌ Docker daemon not responding - start Docker and try again"
        elif "unauthorized" in stderr_lower:
            return "❌ Authentication required - check credentials"
        elif "timeout" in stderr_lower or "deadline exceeded" in stderr_lower:
            return "⏱ Command timed out - Docker daemon may be slow"
        elif "no such file" in stderr_lower:
            return "❌ File or directory not found"
        elif "image not found" in stderr_lower:
            return "❌ Docker image not found in registry"
        else:
            # Generic error with first 100 chars
            return f"❌ Error: {self.stderr[:100]}"


class ErrorRecovery:
    """Retry logic with exponential backoff - Generated by GitHub Copilot"""
    
    @staticmethod
    async def run_with_retry(command_func: Callable, max_retries: int = 3, 
                            backoff_base: float = 2.0) -> Any:
        """
        Run async command with exponential backoff retry.
        
        Args:
            command_func: Async callable
            max_retries: Maximum retry attempts
            backoff_base: Base for exponential backoff (2.0 = 1s, 2s, 4s)
        
        Returns:
            Result from command_func
        
        Raises:
            Last exception if all retries fail
        """
        last_error = None
        
        for attempt in range(max_retries):
            try:
                return await command_func()
            
            except Exception as e:
                last_error = e
                
                if attempt == max_retries - 1:
                    break
                
                # Exponential backoff: 2^attempt seconds
                wait_time = backoff_base ** attempt
                await asyncio.sleep(wait_time)
        
        raise last_error if last_error else RuntimeError("Command failed")
    
    @staticmethod
    async def run_with_fallback(primary_func: Callable, 
                               fallback_func: Callable) -> Any:
        """
        Try primary function, fall back to secondary if it fails.
        
        Args:
            primary_func: Primary async callable
            fallback_func: Fallback async callable
        
        Returns:
            Result from primary, or fallback if primary fails
        """
        try:
            return await primary_func()
        except Exception:
            try:
                return await fallback_func()
            except Exception as e:
                raise RuntimeError(f"Both primary and fallback failed: {e}")


def format_memory(bytes_val: int) -> str:
    """Format bytes as human readable memory - Generated by GitHub Copilot"""
    value = float(bytes_val)
    for unit in ['B', 'KB', 'MB', 'GB', 'TB']:
        if value < 1024:
            return f"{value:.1f}{unit}"
        value /= 1024
    return f"{value:.1f}PB"


def format_size(bytes_val: int) -> str:
    """Format bytes as human readable size"""
    return format_memory(bytes_val)


def format_time(seconds: int) -> str:
    """Format seconds as human readable time"""
    if seconds < 60:
        return f"{seconds}s"
    elif seconds < 3600:
        minutes = seconds // 60
        return f"{minutes}m"
    elif seconds < 86400:
        hours = seconds // 3600
        return f"{hours}h"
    else:
        days = seconds // 86400
        return f"{days}d"