#!/usr/bin/env python3
"""
Docker Monitor - Terminal UI renderer
Author: David Smidke - Accenture
Generated by GitHub Copilot

WCAG 2.1 AA compliant terminal UI with keyboard navigation and color themes.
Security: Input sanitization and bounds checking on all drawing operations.
"""

import curses
import re
import time
from datetime import datetime
from typing import Optional, Tuple, Any, List, cast

from docker_config import Config, EDITABLE_SETTINGS
from docker_models import CacheData
from docker_themes import THEME_DEFINITIONS, THEME_NAMES


class UIRenderer:
    """Terminal UI renderer with theme support - Generated by GitHub Copilot - Anti-flicker optimized"""
    __slots__ = ('stdscr', 'config', 'cache', '_log_level', '_last_h', '_last_w', '_dirty')
    
    def __init__(self, stdscr, config: Config, cache: CacheData):
        self.stdscr = stdscr
        self.config = config
        self.cache = cache
        self._log_level = "INFO"
        self._last_h = 0
        self._last_w = 0
        self._dirty = True
        
        # Initialize curses
        curses.curs_set(0)
        self.stdscr.nodelay(True)
        self._init_colors()
    
    def _init_colors(self):
        """Initialize curses colors from theme"""
        theme = THEME_DEFINITIONS.get(self.config.selected_theme, THEME_DEFINITIONS["Default"])
        curses.start_color()
        curses.use_default_colors()
        
        for pair_id, (fg, bg) in theme.items():
            try:
                curses.init_pair(pair_id, fg, bg)
            except curses.error:
                pass
    
    def safe_addstr(self, y: int, x: int, text: str, attr: int = 0) -> None:
        """Safely add string with bounds checking - Generated by GitHub Copilot"""
        try:
            h, w = self.stdscr.getmaxyx()
            if y < h and x < w:
                # Truncate text to fit window
                available_width = w - x - 1
                if available_width > 0:
                    text = text[:available_width]
                    self.stdscr.addstr(y, x, text, attr)
        except curses.error:
            pass

    def _split_net_io(self, net_io: Optional[str]) -> Tuple[str, str]:
        """Split combined network IO into RX/TX values for compact table rendering - Generated by GitHub Copilot"""
        # Generated by GithubCopilot: normalize untrusted display data to keep layout stable.
        value = (net_io or "").strip()
        if not value:
            return "-", "-"

        if "/" in value:
            parts = [part.strip() for part in value.split("/", 1)]
            rx = parts[0] or "-"
            tx = parts[1] or "-"
            return rx, tx

        return value, "-"

    def _sanitize_status_text(self, status_text: Optional[str]) -> str:
        """Normalize status text by removing duplicated health markers - Generated by GitHub Copilot"""
        # Generated by GithubCopilot: normalize repeated tokens from external command output.
        text = (status_text or "").strip()
        if not text:
            return "-"

        text = re.sub(r"\s+", " ", text)
        for marker in ("(healthy)", "(unhealthy)", "(starting)"):
            doubled_pattern = rf"{re.escape(marker)}\s+{re.escape(marker)}"
            while re.search(doubled_pattern, text):
                text = re.sub(doubled_pattern, marker, text)

        return text
    
    def draw_box(self, y: int, x: int, h: int, w: int, title: str = "", color: int = 1) -> None:
        """Draw a text box with optional title - Generated by GitHub Copilot"""
        try:
            # Draw corners and edges using box drawing characters
            self.stdscr.attron(curses.color_pair(color))
            
            # Top and bottom
            for col in range(x, x + w):
                self.safe_addstr(y, col, "‚îÄ")
                self.safe_addstr(y + h - 1, col, "‚îÄ")
            
            # Left and right
            for row in range(y, y + h):
                self.safe_addstr(row, x, "‚îÇ")
                self.safe_addstr(row, x + w - 1, "‚îÇ")
            
            # Corners
            self.safe_addstr(y, x, "‚îå")
            self.safe_addstr(y, x + w - 1, "‚îê")
            self.safe_addstr(y + h - 1, x, "‚îî")
            self.safe_addstr(y + h - 1, x + w - 1, "‚îò")
            
            # Title
            if title:
                title_str = f" {title} "
                title_x = x + 2
                self.safe_addstr(y, title_x, title_str, curses.color_pair(color) | curses.A_BOLD)
            
            self.stdscr.attroff(curses.color_pair(color))
        except curses.error:
            pass
    
    def render(self) -> None:
        """Render the complete UI with dynamic layout and focus system - Generated by GitHub Copilot"""
        try:
            h, w = self.stdscr.getmaxyx()
            
            # Detect window size changes
            size_changed = (h != self._last_h or w != self._last_w)

            # Always erase each frame to avoid stale artifacts/overlap glitches
            self.stdscr.erase()

            # Keep resize bookkeeping
            if size_changed or self._dirty:
                self._last_h = h
                self._last_w = w
                self._dirty = False
            
            # Minimum size check
            if h < 10 or w < 50:
                self.safe_addstr(h // 2, 5, "Terminal too small. Minimum: 10x50")
                self.stdscr.refresh()
                return
            
            y = 0
            
            # Header (2 rows)
            y = self._draw_header(y, w)
            
            # Calculate dynamic layout for remaining space
            available_height = h - y - 1  # -1 for footer
            
            # Collect visible sections in priority order
            visible_sections = [s for s in self.cache.section_priority 
                               if self.cache.show_sections.get(s, False)]
            
            if not visible_sections:
                self.stdscr.refresh()
                return
            
            # Dynamic height allocation
            # Give focused section more space for scrolling
            allocated_heights = self._allocate_section_heights(visible_sections, available_height)
            self.cache.section_heights = allocated_heights
            
            # Draw sections with allocated heights
            for section_name in visible_sections:
                section_height = allocated_heights.get(section_name, 5)
                
                if section_name == "containers":
                    y = self._draw_containers_section_dynamic(y, w, section_height)
                elif section_name == "stats":
                    y = self._draw_stats_section_dynamic(y, w, section_height)
                elif section_name == "logs":
                    y = self._draw_logs_section_dynamic(y, w, section_height)
                elif section_name == "images":
                    y = self._draw_images_section_dynamic(y, w, section_height)
            
            # Footer - always at bottom
            self._draw_footer(h - 1, w)
            
            # Modals on top
            if self.cache.modal_state:
                self._draw_modal(h, w)
            
            # Force full refresh
            self.stdscr.refresh()
        except Exception as e:
            self._draw_render_error_screen(str(e))

    def _draw_header(self, y: int, w: int) -> int:
        """Draw header with status and summary - Generated by GitHub Copilot"""
        try:
            title = "üê≥ Docker Monitor v2.0"
            status = "‚óè READY" if self.cache.ready else "‚óå LOADING"
            status_color = 2 if self.cache.ready else 4

            self.safe_addstr(y, 2, title, curses.color_pair(5) | curses.A_BOLD)

            status_x = max(2, w - len(status) - 3)
            self.safe_addstr(y, status_x, status, curses.color_pair(status_color) | curses.A_BOLD)

            # Show compact overview line when width allows
            if w > 80:
                running = sum(1 for c in self.cache.containers if c.is_running)
                total = len(self.cache.containers)
                overview = f"Containers: {running}/{total}"
                self.safe_addstr(y, max(2, (w - len(overview)) // 2), overview, curses.color_pair(1) | curses.A_DIM)

            self.safe_addstr(y + 1, 0, "‚îÄ" * w, curses.color_pair(1))
            return y + 2
        except Exception:
            return y + 2

    def _draw_render_error_screen(self, error_message: str) -> None:
        """Draw fallback error screen to avoid blank UI - Generated by GitHub Copilot"""
        try:
            h, w = self.stdscr.getmaxyx()
            self.stdscr.erase()
            title = "Docker Monitor - Render Error"
            hint_1 = "The UI encountered a rendering issue."
            hint_2 = "Press Q to quit or resize terminal to retry."

            self.safe_addstr(max(0, h // 2 - 2), max(0, (w - len(title)) // 2), title, curses.color_pair(3) | curses.A_BOLD)
            self.safe_addstr(max(0, h // 2), max(0, (w - len(hint_1)) // 2), hint_1, curses.color_pair(1))
            self.safe_addstr(max(0, h // 2 + 1), max(0, (w - len(hint_2)) // 2), hint_2, curses.color_pair(4))

            if error_message:
                truncated_error = error_message[:max(10, w - 6)]
                self.safe_addstr(max(0, h // 2 + 3), 3, f"Error: {truncated_error}", curses.color_pair(3))

            self.stdscr.refresh()
        except Exception:
            # Last-resort no-op if terminal state is invalid
            pass
    
    def _allocate_section_heights(self, sections: list, available_height: int) -> dict:
        """Allocate height to sections dynamically - Generated by GitHub Copilot"""
        allocated = {}
        
        if not sections:
            return allocated
        
        # If only one section, give it all available space
        if len(sections) == 1:
            allocated[sections[0]] = available_height
            return allocated
        
        # Calculate content heights for each section
        section_content_heights = {}
        section_content_heights['containers'] = len(self.cache.containers)
        section_content_heights['logs'] = len(self.cache.logs)
        section_content_heights['images'] = len(self.cache.images)
        section_content_heights['stats'] = 8  # Fixed ~8 lines for stats
        
        # If a section has focus, give it more space (up to 2x base)
        base_height = max(3, available_height // len(sections))
        
        for section in sections:
            if section == self.cache.focused_section:
                # Focused section gets priority for space
                content_h = section_content_heights.get(section, 5)
                allocated[section] = min(available_height - (len(sections) - 1) * 3, 
                                       max(base_height * 2, content_h + 2))
            else:
                allocated[section] = base_height
        
        # Normalize to fit in available space
        total_allocated = sum(allocated.values())
        if total_allocated > available_height:
            # Scale down proportionally
            factor = available_height / total_allocated
            for section in allocated:
                allocated[section] = max(3, int(allocated[section] * factor))
        
        return allocated
    
    def _draw_containers_section_dynamic(self, y: int, w: int, section_height: int) -> int:
        """Draw containers with dynamic height, scrolling, and focus indicator - Generated by GitHub Copilot"""
        try:
            if section_height < 4 or y + section_height > self.stdscr.getmaxyx()[0]:
                return y + section_height
            
            box_width = w - 3
            
            # Focus indicator in title
            focus_indicator = "[FOCUS]" if self.cache.focused_section == "containers" else ""
            self.draw_box(y, 1, section_height, box_width, f"üì¶ CONTAINERS {focus_indicator}", 1)
            
            # Column widths
            content_width = box_width - 4
            col_sep = "‚îÇ"

            # Content-aware autosizing (hide optional columns only when required)
            visible_sample = self.cache.containers[:40] if self.cache.containers else []

            column_specs = {
                'name': {
                    'label': '‚óè NAME', 'min': 12, 'max': max(24, content_width), 'weight': 4,
                    'get': lambda c: f"{'‚óè' if c.is_running else '‚óã'} {c.name}"
                },
                'id': {
                    'label': 'ID', 'min': 4, 'max': 12, 'weight': 1,
                    'get': lambda c: c.id[:12]
                },
                'status': {
                    'label': 'STATUS', 'min': 12, 'max': max(24, content_width), 'weight': 5,
                    'get': lambda c: c.status or '-'
                },
                'cpu': {
                    'label': 'CPU', 'min': 5, 'max': 8, 'weight': 2,
                    'get': lambda c: c.cpu_perc or '-'
                },
                'mem': {
                    'label': 'MEM', 'min': 7, 'max': 14, 'weight': 2,
                    'get': lambda c: c.mem_usage or '-'
                },
                'net': {
                    'label': 'NET', 'min': 6, 'max': max(16, content_width), 'weight': 2,
                    'get': lambda c: c.network_name or '-'
                },
                'ip': {
                    'label': 'IP', 'min': 7, 'max': 16, 'weight': 1,
                    'get': lambda c: c.ip_address or '-'
                },
                'ports': {
                    'label': 'PORTS', 'min': 8, 'max': max(20, content_width), 'weight': 2,
                    'get': lambda c: c.ports or '-'
                },
                'rx': {
                    'label': 'RX', 'min': 7, 'max': 12, 'weight': 1,
                    'get': lambda c: self._split_net_io(c.net_io)[0]
                },
                'tx': {
                    'label': 'TX', 'min': 7, 'max': 12, 'weight': 1,
                    'get': lambda c: self._split_net_io(c.net_io)[1]
                },
            }

            core_columns = ['name', 'cpu', 'mem', 'rx', 'tx']
            optional_columns = ['ip', 'ports', 'net', 'id', 'status']
            hide_order = ['status', 'id', 'ip', 'tx', 'rx', 'net', 'ports']

            active_columns = core_columns + optional_columns

            def min_required(columns: list) -> int:
                if not columns:
                    return 0
                return sum(column_specs[col]['min'] for col in columns) + (len(columns) - 1) * len(col_sep)

            # Drop optional columns only if minimum layout does not fit
            while min_required(active_columns) > content_width:
                removed = False
                for col in hide_order:
                    if col in active_columns:
                        active_columns.remove(col)
                        removed = True
                        break
                if not removed:
                    break

            # Compute desired widths from visible data
            desired = {}
            for col in active_columns:
                spec = column_specs[col]
                max_content_len = len(spec['label'])
                for container in visible_sample:
                    value_len = len(spec['get'](container))
                    if value_len > max_content_len:
                        max_content_len = value_len
                desired[col] = min(spec['max'], max(spec['min'], max_content_len))

            # Prefer showing full core-column content before keeping optional columns
            while True:
                core_desired_total = sum(desired[col] for col in core_columns if col in active_columns)
                optional_min_total = sum(column_specs[col]['min'] for col in active_columns if col not in core_columns)
                required_with_optional_mins = core_desired_total + optional_min_total + (len(active_columns) - 1) * len(col_sep)

                if required_with_optional_mins <= content_width:
                    break

                removed = False
                for col in hide_order:
                    if col in active_columns:
                        active_columns.remove(col)
                        removed = True
                        break

                if not removed:
                    break

            # Start with mins
            widths = {col: column_specs[col]['min'] for col in active_columns}
            available_for_columns = content_width - (len(active_columns) - 1) * len(col_sep)
            remaining = max(0, available_for_columns - sum(widths.values()))

            # Pass 1: grow core columns toward desired widths first
            for col in [c for c in core_columns if c in active_columns]:
                if remaining <= 0:
                    break
                need = max(0, desired[col] - widths[col])
                if need > 0:
                    grow = min(need, remaining)
                    widths[col] += grow
                    remaining -= grow

            # Pass 1b: then grow optional columns toward desired widths
            for col in [c for c in active_columns if c not in core_columns]:
                if remaining <= 0:
                    break
                need = max(0, desired[col] - widths[col])
                if need > 0:
                    grow = min(need, remaining)
                    widths[col] += grow
                    remaining -= grow

            # Pass 2: distribute leftovers by weight up to max (no wasted width)
            while remaining > 0:
                grew_any = False
                for col in active_columns:
                    if remaining <= 0:
                        break
                    spec = column_specs[col]
                    if widths[col] < spec['max']:
                        step = min(spec['weight'], spec['max'] - widths[col], remaining)
                        widths[col] += step
                        remaining -= step
                        grew_any = True
                if not grew_any:
                    break

            # Booleans used below for optional fields
            show_net = 'net' in active_columns
            show_ip = 'ip' in active_columns
            show_ports = 'ports' in active_columns
            show_rx = 'rx' in active_columns
            show_tx = 'tx' in active_columns
            show_id = 'id' in active_columns
            show_status = 'status' in active_columns

            name_width = widths['name']
            id_width = widths.get('id', 0)
            status_width = widths.get('status', 0)
            cpu_width = widths['cpu']
            mem_width = widths['mem']
            net_width = widths.get('net', 0)
            ip_width = widths.get('ip', 0)
            ports_width = widths.get('ports', 0)
            rx_width = widths.get('rx', 0)
            tx_width = widths.get('tx', 0)
            
            # Header
            header_parts = [
                "‚óè NAME".ljust(name_width)[:name_width],
                "CPU".ljust(cpu_width)[:cpu_width],
                "MEM".ljust(mem_width)[:mem_width],
            ]
            if show_rx:
                header_parts.append("RX".ljust(rx_width)[:rx_width])
            if show_tx:
                header_parts.append("TX".ljust(tx_width)[:tx_width])
            if show_ip:
                header_parts.append("IP".ljust(ip_width)[:ip_width])
            if show_ports:
                header_parts.append("PORTS".ljust(ports_width)[:ports_width])
            if show_net:
                header_parts.append("NET".ljust(net_width)[:net_width])
            if show_id:
                header_parts.append("ID".ljust(id_width)[:id_width])
            if show_status:
                header_parts.append("STATUS".ljust(status_width)[:status_width])

            def draw_with_separators(draw_y: int, draw_x: int, parts: list, text_attr: int) -> None:
                """Draw row parts with themed separator color - Generated by GitHub Copilot"""
                cursor_x = draw_x
                sep_attr = curses.color_pair(8) | curses.A_DIM
                for idx_part, part in enumerate(parts):
                    self.safe_addstr(draw_y, cursor_x, part, text_attr)
                    cursor_x += len(part)
                    if idx_part < len(parts) - 1:
                        self.safe_addstr(draw_y, cursor_x, col_sep, sep_attr)
                        cursor_x += len(col_sep)

            draw_with_separators(y + 1, 3, header_parts, curses.color_pair(5) | curses.A_BOLD)
            
            # Display containers with scroll support
            max_containers = max(1, section_height - 4)  # reserve one line for selected container network details
            scroll_offset = self.cache.scroll_offsets.get('containers', 0)
            start_idx = max(0, scroll_offset)
            
            # Store content height for scroll calculations
            self.cache.section_content_heights['containers'] = len(self.cache.containers)
            
            for idx, container in enumerate(self.cache.containers[start_idx:start_idx + max_containers]):
                row_y = y + 2 + idx
                actual_idx = start_idx + idx
                
                status_icon = "‚óè" if container.is_running else "‚óã"
                
                # Highlight logic
                is_selected = actual_idx == self.cache.selected_idx
                is_focused = self.cache.focused_section == "containers"
                
                if is_selected and is_focused:
                    attr = curses.color_pair(6) | curses.A_BOLD  # Bright highlight when focused
                elif is_selected:
                    attr = curses.color_pair(5)  # Dimmer highlight when not focused
                elif container.is_running:
                    attr = curses.color_pair(2)
                else:
                    attr = curses.color_pair(3)

                # Subtle zebra striping for readability (non-selected rows only)
                if not is_selected and (idx % 2 == 1):
                    attr |= curses.A_DIM
                
                # Format columns
                name = f"{status_icon} {container.name}".ljust(name_width)[:name_width]
                cid = container.id[:id_width].ljust(id_width)[:id_width] if show_id else ""
                # Smart status truncation: preserve health suffix when present
                status_text = self._sanitize_status_text(container.status)
                health_suffixes = ["(healthy)", "(unhealthy)", "(starting)"]
                kept_suffix = ""
                for suffix in health_suffixes:
                    if suffix in status_text:
                        kept_suffix = suffix
                        break

                if show_status and kept_suffix and status_width > len(kept_suffix) + 2:
                    prefix_budget = status_width - len(kept_suffix) - 1
                    prefix = status_text[:prefix_budget].rstrip()
                    status = f"{prefix} {kept_suffix}"
                else:
                    status = status_text[:status_width]

                status = status.ljust(status_width)[:status_width] if show_status else ""
                cpu = container.cpu_perc[:cpu_width].ljust(cpu_width)[:cpu_width]
                mem = container.mem_usage[:mem_width].ljust(mem_width)[:mem_width]
                net = (container.network_name or "-")[:net_width].ljust(net_width)[:net_width] if show_net else ""
                ip = (container.ip_address or "-")[:ip_width].ljust(ip_width)[:ip_width] if show_ip else ""
                ports = (container.ports or "-")[:ports_width].ljust(ports_width)[:ports_width] if show_ports else ""
                rx_text, tx_text = self._split_net_io(container.net_io)
                rx = rx_text[:rx_width].ljust(rx_width)[:rx_width] if show_rx else ""
                tx = tx_text[:tx_width].ljust(tx_width)[:tx_width] if show_tx else ""
                
                row_parts = [name, cpu, mem]
                if show_rx:
                    row_parts.append(rx)
                if show_tx:
                    row_parts.append(tx)
                if show_ip:
                    row_parts.append(ip)
                if show_ports:
                    row_parts.append(ports)
                if show_net:
                    row_parts.append(net)
                if show_id:
                    row_parts.append(cid)
                if show_status:
                    row_parts.append(status)

                draw_with_separators(row_y, 3, row_parts, attr)
            
            # Selected container network details (ports/net/ip)
            if self.cache.containers and 0 <= self.cache.selected_idx < len(self.cache.containers):
                selected = self.cache.containers[self.cache.selected_idx]
                selected_rx, selected_tx = self._split_net_io(selected.net_io)
                selected_info = (
                    f"NET: {selected.network_name or 'N/A'}  "
                    f"IP: {selected.ip_address or 'N/A'}  "
                    f"PORTS: {selected.ports or 'N/A'}  "
                    f"RX: {selected_rx}  TX: {selected_tx}"
                )
                self.safe_addstr(y + section_height - 2, 3, selected_info[:box_width - 4], curses.color_pair(4) | curses.A_DIM)

            # Show scroll indicator if there are more containers
            remaining = len(self.cache.containers) - (start_idx + max_containers)
            if remaining > 0:
                indicator = f"  ‚Üì {remaining} more"
                indicator_x = max(3, box_width - len(indicator) - 2)
                self.safe_addstr(y + section_height - 2, indicator_x, indicator, curses.color_pair(4) | curses.A_DIM)
            
            return y + section_height
        
        except Exception:
            return y + section_height
    
    def _draw_stats_section_dynamic(self, y: int, w: int, section_height: int) -> int:
        """Draw stats with dynamic height - Generated by GitHub Copilot"""
        try:
            if section_height < 3 or y + section_height > self.stdscr.getmaxyx()[0]:
                return y + section_height
            
            box_width = w - 3
            
            # Focus indicator
            focus_indicator = "[FOCUS]" if self.cache.focused_section == "stats" else ""
            self.draw_box(y, 1, section_height, box_width, f"üìä STATS {focus_indicator}", 1)
            
            # Stats content
            if self.cache.system_stats:
                stats_y = y + 1
                stats = [
                    f"Containers: {self.cache.system_stats.containers_running}/{self.cache.system_stats.containers_total}",
                    f"Memory: {self.cache.system_stats.memory_used}",
                    f"CPUs: {self.cache.system_stats.cpu_available}",
                    f"Uptime: {self.cache.system_stats.uptime_seconds}s",
                ]
                
                self.cache.section_content_heights['stats'] = len(stats) + 2
                
                for idx, stat_line in enumerate(stats[:section_height - 2]):
                    self.safe_addstr(stats_y + idx, 3, stat_line, curses.color_pair(1))
            
            return y + section_height
        
        except Exception:
            return y + section_height
    
    def _draw_logs_section_dynamic(self, y: int, w: int, section_height: int) -> int:
        """Draw logs with dynamic height and scrolling - Generated by GitHub Copilot"""
        try:
            if section_height < 3 or y + section_height > self.stdscr.getmaxyx()[0]:
                return y + section_height
            
            box_width = w - 3
            
            # Focus indicator
            focus_indicator = "[FOCUS]" if self.cache.focused_section == "logs" else ""
            active_name = (self.cache.active_logs_container or "none")[:24]
            self.draw_box(y, 1, section_height, box_width, f"üìù LOGS ({active_name}) {focus_indicator}", 1)
            
            # Display logs with scrolling
            max_logs = section_height - 2
            scroll_offset = self.cache.scroll_offsets.get('logs', 0)
            start_idx = max(0, scroll_offset)
            
            self.cache.section_content_heights['logs'] = len(self.cache.logs)

            if not self.cache.logs:
                hint = "No logs yet for selected container..."
                self.safe_addstr(y + 1, 3, hint[:box_width - 4], curses.color_pair(4) | curses.A_DIM)
                return y + section_height
            
            for idx, log in enumerate(self.cache.logs[start_idx:start_idx + max_logs]):
                row_y = y + 1 + idx
                log_text = f"{log.formatted_time} [{log.container_name}] {log.message}"
                # Truncate to box width
                log_text = log_text[:box_width - 4]
                self.safe_addstr(row_y, 3, log_text, curses.color_pair(1))
            
            return y + section_height
        
        except Exception:
            return y + section_height
    
    def _draw_images_section_dynamic(self, y: int, w: int, section_height: int) -> int:
        """Draw images with dynamic height - Generated by GitHub Copilot"""
        try:
            if section_height < 3 or y + section_height > self.stdscr.getmaxyx()[0]:
                return y + section_height
            
            box_width = w - 3
            
            # Focus indicator
            focus_indicator = "[FOCUS]" if self.cache.focused_section == "images" else ""
            self.draw_box(y, 1, section_height, box_width, f"üñºÔ∏è  IMAGES {focus_indicator}", 1)
            
            # Display images with scrolling
            max_images = section_height - 2
            scroll_offset = self.cache.scroll_offsets.get('images', 0)
            start_idx = max(0, scroll_offset)
            
            self.cache.section_content_heights['images'] = len(self.cache.images)
            
            for idx, image in enumerate(self.cache.images[start_idx:start_idx + max_images]):
                row_y = y + 1 + idx
                img_text = f"{image.repo_tag} ({image.size})"
                img_text = img_text[:box_width - 4]
                self.safe_addstr(row_y, 3, img_text, curses.color_pair(1))
            
            return y + section_height
        
        except Exception:
            return y + section_height
    
    def _draw_footer(self, y: int, w: int) -> None:
        """Draw footer with keyboard hints and focus state - Generated by GitHub Copilot"""
        # Show which section has focus
        focused = self.cache.focused_section.upper()
        focus_info = f"[FOCUS: {focused}]"
        follow_info = "[FOLLOW: selected]"
        containers_on = "ON" if self.cache.show_sections.get('containers', True) else "OFF"
        logs_on = "ON" if self.cache.show_sections.get('logs', True) else "OFF"
        toggles_info = f"[1 Containers:{containers_on}] [2 Logs:{logs_on}]"
        
        # Build hint text with dynamic content
        hints = f" TAB Focus  ‚Üë‚Üì Scroll  PgUp/PgDn Page  Home/End Jump  ENTER Actions  T Theme  Q Quit {toggles_info} {follow_info} {focus_info}"
        
        # Add padding
        footer_padding = w - len(hints)
        footer = hints + " " * max(0, footer_padding)
        footer = footer[:w]
        self.safe_addstr(y, 0, footer, curses.A_REVERSE)
    
    def _draw_modal(self, h: int, w: int) -> None:
        """Draw modal dialog - Generated by GitHub Copilot - Enhanced styling"""
        if not self.cache.modal_state:
            return
        
        if self.cache.modal_state == "MENU":
            self._draw_menu_modal_enhanced(h, w)
        elif self.cache.modal_state == "CONFIRM_ACTION":
            action_label = (self.cache.confirm_action or "action").capitalize()
            self._draw_confirm_modal_enhanced(h, w, f"‚ö†Ô∏è  Confirm {action_label}?", f"Proceed with {action_label.lower()}?", 3)
        elif self.cache.modal_state == "CONFIRM_STOP":
            self._draw_confirm_modal_enhanced(h, w, "‚ö†Ô∏è  Stop Container?", "This will stop the container", 2)
        elif self.cache.modal_state == "CONFIRM_DELETE":
            self._draw_confirm_modal_enhanced(h, w, "üóëÔ∏è  Delete Container?", "This action cannot be undone", 3)
        elif self.cache.modal_state == "CONFIRM_RESTART":
            self._draw_confirm_modal_enhanced(h, w, "üîÑ Restart Container?", "Container will be restarted", 4)
        elif self.cache.modal_state == "INSPECT":
            self._draw_inspect_modal(h, w)
        elif self.cache.modal_state == "SET_THEME_DEFAULT":
            self._draw_theme_confirm_modal(h, w)
        elif self.cache.modal_state == "MSG":
            self._draw_message_modal_enhanced(h, w)
    
    def _draw_menu_modal_enhanced(self, h: int, w: int) -> None:
        """Draw cursor-driven action menu modal - Generated by GitHub Copilot"""
        try:
            # Get current container info
            if not self.cache.containers or self.cache.selected_idx >= len(self.cache.containers):
                return
            
            container = self.cache.containers[self.cache.selected_idx]

            menu_actions = [
                ("start", "Start", "Start this container", 2),
                ("stop", "Stop", "Stop this container", 3),
                ("restart", "Restart", "Restart this container", 4),
                ("update", "Update", "Pull latest image and redeploy", 6),
                ("delete", "Delete", "Remove container permanently", 3),
                ("cancel", "Cancel", "Close menu", 4),
            ]

            if self.cache.menu_cursor < 0:
                self.cache.menu_cursor = 0
            if self.cache.menu_cursor >= len(menu_actions):
                self.cache.menu_cursor = len(menu_actions) - 1
            
            # Calculate modal dimensions - whiptail style
            box_w = min(86, w - 4)
            box_h = 21
            by = max(2, (h - box_h) // 2)
            bx = max(1, (w - box_w) // 2)
            
            # Draw overlay background (semi-transparent effect)
            for row in range(max(0, by - 1), min(h, by + box_h + 1)):
                for col in range(max(0, bx - 1), min(w, bx + box_w + 1)):
                    try:
                        self.stdscr.addstr(row, col, " ", curses.A_REVERSE)
                    except curses.error:
                        pass
            
            # Draw main box with title
            self.draw_box(by, bx, box_h, box_w, "üê≥ CONTAINER MANAGEMENT", 1)
            
            # Container header with status indicator
            status_symbol = "‚ñ∂" if container.is_running else "‚èπ"
            status_color = 2 if container.is_running else 3
            header_text = f"{status_symbol}  {container.display_name}"
            self.safe_addstr(by + 2, bx + 3, header_text, curses.color_pair(5) | curses.A_BOLD)
            
            # Container metadata
            id_text = f"ID:    {container.id[:16]}"
            self.safe_addstr(by + 3, bx + 3, id_text, curses.color_pair(1))
            
            img_text = f"Image: {container.image[:45]}"
            self.safe_addstr(by + 4, bx + 3, img_text, curses.color_pair(1))
            
            status_text = f"Status: {container.status} | CPU: {container.cpu_perc} | Mem: {container.mem_usage}"
            self.safe_addstr(by + 5, bx + 3, status_text, curses.color_pair(status_color))
            
            # Separator line
            sep_line = "‚îÄ" * (box_w - 5)
            self.safe_addstr(by + 6, bx + 2, sep_line, curses.color_pair(1))

            self.safe_addstr(by + 7, bx + 3, "Select action:", curses.color_pair(4) | curses.A_BOLD)

            # Cursor-driven option list
            list_start_y = by + 8
            for idx, (_, label, description, color) in enumerate(menu_actions):
                row_y = list_start_y + idx
                is_selected = (idx == self.cache.menu_cursor)
                prefix = "‚ñ∂" if is_selected else " "
                text = f"{prefix} {label:<10}  {description}"

                if is_selected:
                    attr = curses.color_pair(5) | curses.A_BOLD | curses.A_REVERSE
                else:
                    attr = curses.color_pair(1)

                self.safe_addstr(row_y, bx + 4, text.ljust(box_w - 8), attr)
            
            # Footer instructions
            self.safe_addstr(by + box_h - 2, bx + 2, 
                           "‚Üë/‚Üì Move  ENTER Select  ESC Back  (each action asks Yes/No)",
                           curses.color_pair(4) | curses.A_DIM)
            
        except Exception:
            pass
    
    def _draw_menu_modal(self, y: int, x: int, w: int, h: int) -> None:
        """Draw action menu - Fallback for compatibility"""
        self.safe_addstr(y + 1, x + 2, "Container Actions", curses.A_BOLD)
        self.safe_addstr(y + 3, x + 4, "[S] Start")
        self.safe_addstr(y + 4, x + 4, "[T] Stop")
        self.safe_addstr(y + 5, x + 4, "[R] Restart")
        self.safe_addstr(y + 6, x + 4, "[D] Delete")
        self.safe_addstr(y + 7, x + 4, "[ESC] Cancel")
    
    def _draw_confirm_modal_enhanced(self, h: int, w: int, title: str, message: str, color: int) -> None:
        """Draw enhanced confirmation modal"""
        try:
            box_w = 55
            box_h = 9
            by = max(2, (h - box_h) // 2)
            bx = max(2, (w - box_w) // 2)
            
            # Background
            for row in range(max(0, by - 1), min(h, by + box_h + 1)):
                for col in range(max(0, bx - 1), min(w, bx + box_w + 1)):
                    try:
                        self.stdscr.addstr(row, col, " ", curses.A_REVERSE)
                    except curses.error:
                        pass
            
            # Draw box
            self.draw_box(by, bx, box_h, box_w, title, color)
            
            # Container info
            if self.cache.containers and self.cache.selected_idx < len(self.cache.containers):
                container = self.cache.containers[self.cache.selected_idx]
                self.safe_addstr(by + 2, bx + 3, f"Container: {container.display_name}", 
                               curses.color_pair(5) | curses.A_BOLD)
                self.safe_addstr(by + 3, bx + 3, f"ID: {container.id[:24]}", curses.color_pair(1))
            
            # Message
            self.safe_addstr(by + 4, bx + 3, message, curses.color_pair(4))

            # Confirm/Cancel options with cursor for action confirmations
            if self.cache.modal_state == "CONFIRM_ACTION":
                yes_selected = (self.cache.confirm_cursor == 0)
                no_selected = not yes_selected

                yes_attr = (curses.color_pair(2) | curses.A_BOLD | curses.A_REVERSE) if yes_selected else (curses.color_pair(2) | curses.A_BOLD)
                no_attr = (curses.color_pair(3) | curses.A_BOLD | curses.A_REVERSE) if no_selected else (curses.color_pair(3) | curses.A_BOLD)

                self.safe_addstr(by + 6, bx + 3, "[ YES ]", yes_attr)
                self.safe_addstr(by + 6, bx + 17, "[ NO ]", no_attr)
                self.safe_addstr(by + 7, bx + 3, "‚Üê/‚Üí Move  ENTER Select  ESC Back", curses.color_pair(4) | curses.A_DIM)
            else:
                self.safe_addstr(by + 6, bx + 3, "[Y] Confirm", curses.color_pair(2))
                self.safe_addstr(by + 6, bx + 20, "[N] Cancel", curses.color_pair(3))
            
        except Exception:
            pass
    
    def _draw_confirm_modal(self, y: int, x: int, w: int, message: str, hint: str) -> None:
        """Draw confirmation modal - Fallback"""
        self.safe_addstr(y + 2, x + 2, message, curses.A_BOLD)
        self.safe_addstr(y + 4, x + 2, hint)
    
    def _draw_message_modal_enhanced(self, h: int, w: int) -> None:
        """Draw enhanced message modal"""
        try:
            box_w = 60
            box_h = 7
            by = max(2, (h - box_h) // 2)
            bx = max(2, (w - box_w) // 2)
            
            # Background
            for row in range(max(0, by - 1), min(h, by + box_h + 1)):
                for col in range(max(0, bx - 1), min(w, bx + box_w + 1)):
                    try:
                        self.stdscr.addstr(row, col, " ", curses.A_REVERSE)
                    except curses.error:
                        pass
            
            # Draw box
            self.draw_box(by, bx, box_h, box_w, "‚úì Status", 2)
            
            # Message
            msg_lines = self.cache.modal_msg.split('\n')
            for idx, line in enumerate(msg_lines[:3]):
                self.safe_addstr(by + 2 + idx, bx + 3, line[:box_w - 6], curses.color_pair(1))
            
            # Close hint
            self.safe_addstr(by + box_h - 2, bx + 3, "[Any key to close]", 
                           curses.color_pair(4) | curses.A_DIM)
            
        except Exception:
            pass
    
    def _draw_theme_confirm_modal(self, h: int, w: int) -> None:
        """Draw confirmation modal for setting theme as default - Generated by GitHub Copilot"""
        try:
            if self.cache.theme_cursor < 0 or self.cache.theme_cursor >= len(THEME_NAMES):
                return
            
            selected_theme = THEME_NAMES[self.cache.theme_cursor]
            box_w = 60
            box_h = 10
            by = max(2, (h - box_h) // 2)
            bx = max(2, (w - box_w) // 2)
            
            # Background overlay
            for row in range(max(0, by - 1), min(h, by + box_h + 1)):
                for col in range(max(0, bx - 1), min(w, bx + box_w + 1)):
                    try:
                        self.stdscr.addstr(row, col, " ", curses.A_REVERSE)
                    except curses.error:
                        pass
            
            # Draw box
            self.draw_box(by, bx, box_h, box_w, "üé® Set As Default?", 6)
            
            # Message
            msg = f"Set '{selected_theme}' as your default theme?"
            self.safe_addstr(by + 2, bx + 3, msg, curses.color_pair(1))
            self.safe_addstr(by + 3, bx + 3, "This will be applied on next startup.", curses.color_pair(4) | curses.A_DIM)
            
            # Buttons
            self.safe_addstr(by + 5, bx + 3, "[Y] Yes, save as default", curses.color_pair(2) | curses.A_BOLD)
            self.safe_addstr(by + 6, bx + 3, "[N] No, just preview", curses.color_pair(3))
            self.safe_addstr(by + 7, bx + 3, "[ESC] Cancel", curses.color_pair(4))
            
        except Exception:
            pass
    
    def _draw_inspect_modal(self, h: int, w: int) -> None:
        """Draw container inspect/details modal - Generated by GitHub Copilot"""
        try:
            if not self.cache.containers or self.cache.selected_idx >= len(self.cache.containers):
                return
            
            container = self.cache.containers[self.cache.selected_idx]
            box_w = min(80, w - 4)
            box_h = h - 6
            by = 2
            bx = max(1, (w - box_w) // 2)
            
            # Draw box
            self.draw_box(by, bx, box_h, box_w, f"üîç INSPECT: {container.display_name}", 6)

            detail_y = by + 2
            max_lines = box_h - 4

            # Prefer live docker inspect output if available
            inspect_text = (self.cache.modal_msg or "").strip()
            if inspect_text and (inspect_text.startswith("[") or inspect_text.startswith("{")):
                self.safe_addstr(detail_y, bx + 3, "Live docker inspect output:", curses.color_pair(4) | curses.A_BOLD)
                detail_y += 1

                for line in inspect_text.splitlines()[:max_lines - 1]:
                    if detail_y >= by + box_h - 2:
                        break
                    clean_line = line[:box_w - 6]
                    self.safe_addstr(detail_y, bx + 3, clean_line, curses.color_pair(1))
                    detail_y += 1
            else:
                # Fallback to cached summary if inspect output is unavailable
                details = [
                    ("ID:", container.id),
                    ("Image:", container.image),
                    ("Status:", container.status),
                    ("Name:", container.name),
                    ("Created:", getattr(container, 'created', 'N/A')),
                    ("Ports:", container.ports if hasattr(container, 'ports') else "N/A"),
                    ("Command:", container.command if hasattr(container, 'command') else "N/A"),
                ]

                for label, value in details:
                    if detail_y >= by + box_h - 2:
                        break
                    val_str = str(value)[:box_w - len(label) - 10]
                    self.safe_addstr(detail_y, bx + 3, f"{label:<10} {val_str}", curses.color_pair(1))
                    detail_y += 1
            
            # Footer
            self.safe_addstr(by + box_h - 2, bx + 3, "[Any key to close]", curses.color_pair(4) | curses.A_DIM)
            
        except Exception:
            pass
    
    def _draw_message_modal(self, y: int, x: int, w: int, message: str) -> None:
        """Draw message dialog - Fallback"""
        self.safe_addstr(y + 2, x + 2, message[:w - 4])
        self.safe_addstr(y + 4, x + 2, "[Any key to close]", curses.A_DIM)
    
    def draw_settings_screen(self) -> None:
        """Draw settings/configuration screen - Enhanced - Generated by GitHub Copilot"""
        try:
            self.stdscr.clear()
            h, w = self.stdscr.getmaxyx()
            
            # Draw title
            self.safe_addstr(1, 2, "‚öôÔ∏è  Configuration Settings", curses.color_pair(5) | curses.A_BOLD)
            self.safe_addstr(2, 2, "‚îÄ" * (w - 4), curses.color_pair(1))
            
            # Draw settings with proper formatting
            for idx, setting in enumerate(EDITABLE_SETTINGS):
                row_y = 4 + idx
                if row_y >= h - 3:
                    break
                
                value = getattr(self.config, setting.key, "")
                
                # Create formatted line: [>] Label - Description (current value)
                prefix = "‚ñ∫" if idx == self.cache.settings_cursor else " "
                label = setting.label.ljust(28)
                current_val = f"[{value}]"
                
                line = f"{prefix} {label} {current_val}"
                
                # Color: highlight current selection
                if idx == self.cache.settings_cursor:
                    attr = curses.color_pair(6) | curses.A_BOLD
                else:
                    attr = curses.color_pair(1)
                
                self.safe_addstr(row_y, 3, line, attr)
                
                # Show description in dimmed text
                self.safe_addstr(row_y, 3 + len(line) + 2, setting.description[:40], 
                               curses.color_pair(4) | curses.A_DIM)
            
            # Footer
            footer_y = h - 2
            self.safe_addstr(footer_y, 2, "‚îÄ" * (w - 4), curses.color_pair(1))
            self.safe_addstr(footer_y + 1, 2, " ‚Üë‚Üì Navigate  +/- Adjust  ESC Exit ", curses.A_REVERSE)
            
            self.stdscr.refresh()
        except Exception:
            pass
    
    def draw_theme_screen(self) -> None:
        """Draw theme selection screen with visual previews - Generated by GitHub Copilot"""
        try:
            self.stdscr.clear()
            h, w = self.stdscr.getmaxyx()
            
            # Title with emoji
            self.safe_addstr(1, 2, "üé® THEME SELECTOR", curses.color_pair(5) | curses.A_BOLD)
            self.safe_addstr(2, 2, "‚îÄ" * (w - 4), curses.color_pair(1))
            
            # Theme descriptions with color codes
            theme_descs = {
                "Default": "Cyan/Green palette",
                "Dracula": "Purple/Dark theme",
                "Nord": "Arctic blue tones",
                "Gruvbox": "Warm retro contrast",
                "OneDark": "Atom-inspired dark",
                "Solarized": "Warm/Cool balance",
                "Solarized Light": "Light background variant",
                "Monokai": "High contrast colors",
                "Catppuccin Mocha": "Muted pastel dark",
                "TTY": "Classic terminal green",
                "Matrix": "Neon green on black",
            }
            
            for idx, theme_name in enumerate(THEME_NAMES):
                row_y = 4 + idx
                if row_y >= h - 4:
                    break
                
                # Selection indicator
                prefix = "‚ñ∂" if idx == self.cache.theme_cursor else " "
                theme_item = f"{prefix}  {theme_name}"
                desc = theme_descs.get(theme_name, "")
                
                # Highlight current selection with different color
                if idx == self.cache.theme_cursor:
                    attr = curses.color_pair(6) | curses.A_BOLD
                else:
                    attr = curses.color_pair(1)
                
                # Draw theme name
                self.safe_addstr(row_y, 3, theme_item.ljust(22), attr)
                # Draw description
                self.safe_addstr(row_y, 28, desc[:45], curses.color_pair(4) | curses.A_DIM)
            
            # Footer with instructions
            footer_y = h - 2
            self.safe_addstr(footer_y, 2, "‚îÄ" * (w - 4), curses.color_pair(1))
            hint = " ‚Üë‚Üì Navigate  ENTER Preview+Confirm  Y Save  N Session Only  ESC Cancel "
            self.safe_addstr(footer_y + 1, 2, hint, curses.A_REVERSE)

            if self.cache.modal_state == "SET_THEME_DEFAULT":
                self._draw_theme_confirm_modal(h, w)
            
            self.stdscr.refresh()
        except Exception:
            pass    
    def handle_mouse_event(self, key: int) -> Optional[str]:
        """
        Handle mouse events and return action.
        Generated by GitHub Copilot - Accessibility: Mouse support for non-keyboard users
        
        Returns:
            Action string or None if no action
        """
        try:
            if key != curses.KEY_MOUSE:
                return None
            
            _, mx, my, _, bstate = curses.getmouse()
            
            # Button 1 = left click
            if bstate & curses.BUTTON1_CLICKED:
                return self._handle_left_click(mx, my)
            
            # Button 3 = right click
            elif bstate & curses.BUTTON3_CLICKED:
                return self._handle_right_click(mx, my)
            
            # Button 4 = scroll up
            elif bstate & curses.BUTTON4_PRESSED:
                return "scroll_up"
            
            # Button 5 = scroll down  
            elif bstate & curses.BUTTON5_PRESSED:
                return "scroll_down"
        
        except Exception:
            pass
        
        return None
    
    def _handle_left_click(self, mx: int, my: int) -> Optional[str]:
        """Handle left mouse click"""
        h, w = self.stdscr.getmaxyx()
        
        # Container list area (typically left side)
        if mx < w // 2:
            # Calculate which container is at this Y position
            container_start_y = 3
            selected_idx = my - container_start_y
            if 0 <= selected_idx < len(self.cache.containers):
                return f"select_container_{selected_idx}"
        
        # Buttons area (right side)
        else:
            if my == h - 2:
                if mx < 10:
                    return "action_start"
                elif mx < 20:
                    return "action_stop"
                elif mx < 30:
                    return "action_restart"
        
        return None
    
    def _handle_right_click(self, mx: int, my: int) -> Optional[str]:
        """Handle right mouse click - show context menu"""
        return "show_context_menu"
    
    def draw_metrics_panel(self, start_y: int, x: int, width: int) -> int:
        """
        Draw real-time metrics panel with trends.
        Generated by GitHub Copilot - Green Software: CPU-efficient trending visualization
        
        Returns:
            Y position after panel (for next panel)
        """
        try:
            from docker_metrics import MetricsCollector, MetricsFormatter
            
            y = start_y
            h, w = self.stdscr.getmaxyx()
            
            if not hasattr(self.cache, 'metrics_collector'):
                return y
            
            metrics_collector = cast(Any, self.cache.metrics_collector)
            if metrics_collector is None:
                return y
            
            # Title
            self.safe_addstr(y, x, "üìä Metrics Trends", curses.color_pair(5) | curses.A_BOLD)
            y += 1
            self.safe_addstr(y, x, "‚îÄ" * (width - 2), curses.color_pair(1))
            y += 1
            
            # Get top consumers
            top_cpu: List[tuple[str, float]] = list(metrics_collector.get_top_cpu_consumers(limit=3) or [])
            top_mem: List[tuple[str, float]] = list(metrics_collector.get_top_memory_consumers(limit=3) or [])
            
            # CPU consumers
            self.safe_addstr(y, x, "üî¥ Top CPU:", curses.color_pair(3))
            y += 1
            for container_id, cpu_pct in top_cpu:
                buffer = metrics_collector.get_buffer(container_id)
                if buffer:
                    trend = buffer.get_trend_symbols("cpu")
                    line = f"  {container_id[:8]}  {cpu_pct:5.1f}%  {trend}"
                    self.safe_addstr(y, x + 2, line, curses.color_pair(2))
                    y += 1
            
            y += 1
            
            # Memory consumers
            self.safe_addstr(y, x, "üü¢ Top Memory:", curses.color_pair(3))
            y += 1
            for container_id, mem_pct in top_mem:
                buffer = metrics_collector.get_buffer(container_id)
                if buffer:
                    trend = buffer.get_trend_symbols("memory")
                    line = f"  {container_id[:8]}  {mem_pct:5.1f}%  {trend}"
                    self.safe_addstr(y, x + 2, line, curses.color_pair(2))
                    y += 1
            
            return y
        
        except Exception:
            return start_y + 2
    
    def draw_error_message(self, message: str, duration: float = 3.0) -> None:
        """
        Display error message with auto-dismiss.
        Generated by GitHub Copilot - UX: Clear error feedback
        """
        try:
            h, w = self.stdscr.getmaxyx()
            
            # Truncate if too long
            if len(message) > w - 6:
                message = message[:w - 9] + "..."
            
            # Draw error box at bottom
            error_y = h - 4
            error_x = 2
            box_width = min(len(message) + 4, w - 4)
            
            # Draw background
            for row in range(error_y, min(error_y + 3, h)):
                self.safe_addstr(row, error_x, "‚ñà" * box_width, curses.color_pair(7))
            
            # Draw error text
            self.safe_addstr(error_y + 1, error_x + 2, message, curses.color_pair(7) | curses.A_BOLD)
            
            # Store timer for auto-dismiss
            self.cache.msg_timer = time.time() + duration
        
        except Exception:
            pass
    
    def enable_mouse(self) -> None:
        """Enable mouse support in curses - Generated by GitHub Copilot"""
        try:
            curses.mousemask(
                curses.BUTTON1_CLICKED | 
                curses.BUTTON3_CLICKED |
                curses.BUTTON4_PRESSED |
                curses.BUTTON5_PRESSED
            )
        except Exception:
            pass