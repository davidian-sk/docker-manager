#!/usr/bin/env python3
"""
Docker Monitor - Configuration management
Author: David Smidke - Accenture
Generated by GitHub Copilot

Centralized configuration with persistent settings and environment-aware defaults.
"""

import json
import logging
from dataclasses import dataclass
from pathlib import Path
from typing import Any, Dict, Optional

# ============================================================================
# CONFIGURATION & SETTINGS FILE
# ============================================================================

SETTINGS_FILE = Path.home() / ".docker_monitor.json"
APP_VERSION = "2.1.0"
UPDATE_CHECK_URL = "https://api.github.com/repos/accenture/docker-monitor/releases/latest"
UPDATE_CHECK_INTERVAL = 86400  # 24 hours


@dataclass
class SettingDef:
    """Definition of an editable setting"""
    key: str
    label: str
    stype: str  # "int", "float", "bool", "str"
    smin: float = 0
    smax: float = 100
    step: float = 1
    description: str = ""


# Generated by GitHub Copilot - Security: Input validation with type coercion
EDITABLE_SETTINGS = [
    SettingDef("max_log_rows", "Log Rows Shown", "int", 5, 100, 5, "Max log entries displayed in the panel"),
    SettingDef("update_interval", "Data Refresh (sec)", "float", 0.5, 10.0, 0.5, "Seconds between Docker API scans"),
    SettingDef("ui_refresh_interval", "UI Refresh (ms)", "float", 20, 500, 20, "Milliseconds between screen redraws"),
    SettingDef("log_tail_lines", "Lines per Container", "int", 10, 500, 10, "Lines to tail from container logs"),
    SettingDef("show_network_stats", "Show Network Panel", "bool", 0, 1, 1, "Display host network throughput"),
    SettingDef("show_image_stats", "Show Image Stats", "bool", 0, 1, 1, "Display Docker image information"),
    SettingDef("command_timeout", "Command Timeout (sec)", "int", 3, 60, 3, "Timeout for Docker commands"),
    SettingDef("max_containers_displayed", "Max Containers", "int", 10, 100, 5, "Maximum containers to display"),
    SettingDef("enable_update_check", "Check Updates", "bool", 0, 1, 1, "Automatically check for app updates"),
]

FOCUS_SECTIONS = ['containers', 'logs', 'images', 'stats']


class Config:
    """Centralized application configuration - Generated by GitHub Copilot"""
    __slots__ = (
        'update_interval', 'ui_refresh_interval', 'log_tail_lines', 'max_log_rows',
        'show_network_stats', 'show_image_stats', 'selected_theme', 'command_timeout',
        'max_containers_displayed', 'enable_update_check', 'last_update_check',
        '_log'
    )

    def __init__(self):
        # Default configuration (green software: balanced performance)
        self.update_interval = 2.0
        self.ui_refresh_interval = 0.05  # 50ms for responsive UI
        self.log_tail_lines = 50
        self.max_log_rows = 15
        self.show_network_stats = True
        self.show_image_stats = False
        self.selected_theme = "Default"
        self.command_timeout = 10
        self.max_containers_displayed = 30
        self.enable_update_check = True
        self.last_update_check = 0.0
        
        self._log = logging.getLogger(__name__)
        self._load_settings()

    def _load_settings(self):
        """Load settings from persistent file with validation"""
        if not SETTINGS_FILE.exists():
            return
        
        try:
            saved = json.loads(SETTINGS_FILE.read_text())
            
            for sd in EDITABLE_SETTINGS:
                if sd.key not in saved:
                    continue
                
                val = saved[sd.key]
                
                # Generated by GitHub Copilot - Type coercion with validation
                try:
                    if sd.stype == "bool":
                        val = bool(val)
                    elif sd.stype == "int":
                        val = max(int(sd.smin), min(int(sd.smax), int(val)))
                    elif sd.stype == "float":
                        val = max(float(sd.smin), min(float(sd.smax), float(val)))
                    elif sd.stype == "str":
                        val = str(val)
                    
                    setattr(self, sd.key, val)
                except (ValueError, TypeError) as e:
                    self._log.debug(f"Skipping invalid setting {sd.key}: {e}")
            
            # Validate theme
            if "selected_theme" in saved:
                from docker_themes import THEME_NAMES
                loaded_theme = saved.get("selected_theme", "Default")
                if loaded_theme in THEME_NAMES:
                    self.selected_theme = loaded_theme
            
            if "last_update_check" in saved:
                self.last_update_check = float(saved.get("last_update_check", 0))
                
        except Exception as e:
            self._log.warning(f"Failed to load settings: {e}")

    def save_settings(self):
        """Persist settings to file - Generated by GitHub Copilot"""
        try:
            data = {sd.key: getattr(self, sd.key) for sd in EDITABLE_SETTINGS}
            data["selected_theme"] = self.selected_theme
            data["last_update_check"] = self.last_update_check
            SETTINGS_FILE.write_text(json.dumps(data, indent=2))
        except Exception as e:
            self._log.error(f"Failed to save settings: {e}")

    def get_setting(self, key: str) -> Any:
        """Safely get a setting value"""
        return getattr(self, key, None)

    def set_setting(self, key: str, value: Any) -> bool:
        """Safely set a setting value with validation - Generated by GitHub Copilot"""
        try:
            setting = next((s for s in EDITABLE_SETTINGS if s.key == key), None)
            if not setting:
                return False
            
            if setting.stype == "bool":
                value = bool(value)
            elif setting.stype == "int":
                value = max(int(setting.smin), min(int(setting.smax), int(value)))
            elif setting.stype == "float":
                value = max(float(setting.smin), min(float(setting.smax), float(value)))
            
            setattr(self, key, value)
            return True
        except (ValueError, TypeError):
            return False

class CustomCommandTemplates:
    """Custom Docker command templates - Generated by GitHub Copilot"""
    
    # Default templates
    DEFAULT_TEMPLATES = {
        'ps': 'docker ps -a --format "{{.ID}}|{{.Names}}"',
        'stats': 'docker stats --no-stream --format "{{.ID}}|{{.Name}}|{{.CPUPerc}}"',
        'logs': 'docker logs --tail {lines} {container}',
        'inspect_env': 'docker inspect {container} --format "{{json .Config.Env}}"',
        'top_cpu': 'docker stats --no-stream --format "table {{.Container}}\t{{.CPUPerc}}"',
        'top_memory': 'docker stats --no-stream --format "table {{.Container}}\t{{.MemUsage}}"',
    }
    
    def __init__(self):
        self.templates = self.DEFAULT_TEMPLATES.copy()
    
    def get_template(self, name: str) -> Optional[str]:
        """Get template by name"""
        return self.templates.get(name)
    
    def set_template(self, name: str, template: str) -> bool:
        """Set custom template"""
        if not template or not name:
            return False
        self.templates[name] = template
        return True
    
    def render(self, template_name: str, **kwargs) -> str:
        """Render template with variables"""
        template = self.get_template(template_name)
        if not template:
            return ""
        
        try:
            return template.format(**kwargs)
        except KeyError as e:
            return f"ERROR: Missing variable {e}"


class KeyBindings:
    """Customizable keybindings - Generated by GitHub Copilot"""
    
    # Default keybindings
    DEFAULT_BINDINGS = {
        # Navigation
        'UP': 'move_up',
        'DOWN': 'move_down',
        'PAGE_UP': 'page_up',
        'PAGE_DOWN': 'page_down',
        'HOME': 'first_item',
        'END': 'last_item',
        
        # Actions
        'ENTER': 'select_container',
        'SPACE': 'toggle_container',
        'DELETE': 'delete_container',
        'R': 'restart_container',
        'S': 'stop_container',
        'K': 'kill_container',
        
        # UI  
        'T': 'toggle_theme',
        'C': 'config_mode',
        'L': 'toggle_logs',
        'I': 'toggle_images',
        'N': 'toggle_network',
        '1': 'toggle_section_1',
        '2': 'toggle_section_2',
        '3': 'toggle_section_3',
        '4': 'toggle_section_4',
        
        # Update
        'U': 'update_container',
        'P': 'pause_container',
        
        # Search/Filter
        '/': 'search_mode',
        'F': 'filter_mode',
        
        # System
        'H': 'help',
        'Q': 'quit',
    }
    
    def __init__(self):
        self.bindings = self.DEFAULT_BINDINGS.copy()
    
    def get_action(self, key: str) -> Optional[str]:
        """Get action for key"""
        return self.bindings.get(key.upper())
    
    def set_binding(self, key: str, action: str) -> bool:
        """Set custom keybinding"""
        if not key or not action:
            return False
        self.bindings[key.upper()] = action
        return True
    
    def get_keys_for_action(self, action: str) -> list[str]:
        """Get all keys bound to action"""
        return [k for k, v in self.bindings.items() if v == action]