#!/usr/bin/env python3
"""
Docker Monitor - Main application class
Author: David Smidke - Accenture
Generated by GitHub Copilot

Main orchestration logic for the Docker monitoring application.
"""

import asyncio
import curses
import logging
import signal
import sys
import time
import threading
from typing import Optional

from docker_config import Config, EDITABLE_SETTINGS, CustomCommandTemplates, KeyBindings
from docker_models import CacheData
from docker_themes import THEME_NAMES, init_curses_colors
from docker_ui import UIRenderer
from docker_worker import DataCollectionWorker, perform_docker_action
from docker_network import CommandExecutor, check_docker_permissions
from docker_commands import ContainerCommands, ImageCommands, NetworkCommands, VolumeCommands, SystemCommands
from docker_tasks import TaskManager
from docker_metrics import MetricsCollector
from docker_events import DockerEventMonitor


class DockerMonitor:
    """Main Docker Monitor application - Generated by GitHub Copilot"""
    
    def __init__(self, stdscr):
        self.stdscr = stdscr
        self.config = Config()
        self.cache = CacheData()
        self._log = logging.getLogger(__name__)
        self.running = True
        
        # Initialize themes
        init_curses_colors(self.config.selected_theme)
        
        # Initialize UI
        self.ui = UIRenderer(stdscr, self.config, self.cache)
        self.ui.enable_mouse()  # Enable mouse support
        
        # Initialize worker
        self.worker = DataCollectionWorker(self.config, self.cache)
        self.executor = CommandExecutor(self.config.command_timeout)
        
        # Initialize new modules from lazydocker-inspired patterns
        self.task_manager = TaskManager()  # Task deduplication
        self.metrics_collector = MetricsCollector()  # Real-time metrics
        self.event_monitor = DockerEventMonitor()  # Event streaming
        
        # Initialize command modules
        self.container_commands = ContainerCommands(self.executor)
        self.image_commands = ImageCommands(self.executor)
        self.network_commands = NetworkCommands(self.executor)
        self.volume_commands = VolumeCommands(self.executor)
        self.system_commands = SystemCommands(self.executor)
        
        # Configuration
        self.command_templates = CustomCommandTemplates()
        self.keybindings = KeyBindings()
        
        # Attach to cache for use by worker and UI
        self.cache.task_manager = self.task_manager
        self.cache.metrics_collector = self.metrics_collector
        self.cache.event_monitor = self.event_monitor
        
        # Event loop for async operations
        self.loop: Optional[asyncio.AbstractEventLoop] = None
        self.worker_task: Optional[asyncio.Task] = None
        self.worker_thread: Optional[threading.Thread] = None
        self._theme_before_preview = self.config.selected_theme
    
    def _setup_signal_handlers(self):
        """Setup signal handlers for graceful shutdown"""
        def handle_signal(signum, frame):
            self.cache.running = False
            self.running = False
        
        signal.signal(signal.SIGINT, handle_signal)
        signal.signal(signal.SIGTERM, handle_signal)
    
    def run(self):
        """Main application loop"""
        self._setup_signal_handlers()
        
        try:
            # Create event loop for worker in separate thread - Generated by GitHub Copilot
            event_loop = asyncio.new_event_loop()
            self.loop = event_loop
            
            # Run event loop in background thread
            def run_event_loop():
                asyncio.set_event_loop(event_loop)
                try:
                    # Run both worker and event monitoring
                    event_loop.run_until_complete(
                        asyncio.gather(
                            self.worker.run(),
                            self._setup_and_monitor_events(),
                            return_exceptions=True
                        )
                    )
                finally:
                    # Ensure all pending tasks are finalized before loop close
                    pending = [task for task in asyncio.all_tasks(event_loop) if not task.done()]
                    for task in pending:
                        task.cancel()
                    if pending:
                        event_loop.run_until_complete(asyncio.gather(*pending, return_exceptions=True))
                    event_loop.run_until_complete(event_loop.shutdown_asyncgens())
                    event_loop.close()
            
            self.worker_thread = threading.Thread(target=run_event_loop, daemon=True)
            self.worker_thread.start()
            
            # Main UI loop (non-blocking)
            self._ui_loop()
            
            # Stop worker
            self.cache.running = False
            if self.worker_thread and self.worker_thread.is_alive():
                self.worker_thread.join(timeout=2.0)
            
        except KeyboardInterrupt:
            self._log.info("Interrupted by user")
        except Exception as e:
            self._log.error(f"Fatal error: {e}", exc_info=True)
        finally:
            self._cleanup()
    
    async def _setup_and_monitor_events(self):
        """Setup event handlers and start monitoring - Generated by GitHub Copilot"""
        try:
            # Setup event handlers for container state changes
            async def on_container_change(event):
                from docker_events import EventType
                if event.type == EventType.CONTAINER:
                    if event.action in ["start", "stop", "die"]:
                        # Mark cache as needing refresh
                        self.cache.ready = False
            
            # Subscribe to container events
            self.event_monitor.subscribe("container:*", on_container_change)
            
            # Start monitoring
            await self.event_monitor.start_monitoring()
            
            # Keep monitoring until shutdown
            while self.cache.running:
                await asyncio.sleep(1)
        
        except asyncio.CancelledError:
            pass
        except Exception as e:
            self._log.debug(f"Event monitoring error: {e}")
        finally:
            try:
                await self.event_monitor.stop_monitoring()
            except RuntimeError:
                # Event loop may already be closed during shutdown
                pass
            except Exception as e:
                self._log.debug(f"Event monitor final stop error: {e}")
    
    def _ui_loop(self):
        """Ultra-responsive non-blocking UI event loop - Generated by GitHub Copilot"""
        self.stdscr.nodelay(True)  # Non-blocking input - CRITICAL for responsiveness
        self.stdscr.timeout(10)    # 10ms timeout for snappy input (100 FPS potential)
        
        last_render_time = 0
        min_render_interval = 0.016  # ~60 FPS max
        first_frame_rendered = False
        
        while self.running and self.cache.running:
            current_time = time.time()
            
            try:
                # Non-blocking input check
                key = self.stdscr.getch()
                
                # Process input immediately (no delay)
                if key != -1:
                    self._handle_input(key)
                    last_render_time = 0  # Force immediate re-render on input
                
            except KeyboardInterrupt:
                break
            except Exception as e:
                self._log.debug(f"UI loop error: {e}")
            
            # Render UI at controlled frame rate to prevent screen tearing
            if (not first_frame_rendered) or (current_time - last_render_time >= min_render_interval):
                try:
                    if self.cache.settings_mode:
                        self.ui.draw_settings_screen()
                    elif self.cache.theme_mode:
                        self.ui.draw_theme_screen()
                    else:
                        self.ui.render()
                    last_render_time = current_time
                    first_frame_rendered = True
                except Exception as e:
                    # Keep UI responsive and visible even on repeated render issues
                    self._log.debug(f"Render error: {e}")
                    try:
                        self.stdscr.erase()
                        self.stdscr.addstr(1, 2, "Docker Monitor failed to render a frame", curses.A_BOLD)
                        self.stdscr.addstr(2, 2, f"Error: {str(e)[:120]}")
                        self.stdscr.addstr(4, 2, "Press Q to quit. The app will keep retrying render.")
                        self.stdscr.refresh()
                    except Exception:
                        pass
            
            # Very short sleep to prevent CPU spinning, but allow quick response
            time.sleep(0.001)
    
    def _handle_input(self, key: int):
        """Handle keyboard and mouse input - Generated by GitHub Copilot"""
        try:
            # Handle mouse events
            import curses
            if key == curses.KEY_MOUSE:
                mouse_action = self.ui.handle_mouse_event(key)
                if mouse_action:
                    self._execute_action(mouse_action)
                return
            
            # Modal handling
            if self.cache.modal_state == "MENU":
                self._handle_menu_input(key)
            elif self.cache.modal_state == "CONFIRM_ACTION":
                self._handle_confirm_input(key)
            elif self.cache.modal_state in ["CONFIRM_STOP", "CONFIRM_DELETE", "CONFIRM_RESTART"]:
                self._handle_confirm_input(key)
            elif self.cache.modal_state == "SET_THEME_DEFAULT":
                self._handle_theme_confirm_input(key)
            elif self.cache.modal_state == "INSPECT":
                if key != -1:
                    self.cache.modal_state = None
            elif self.cache.modal_state == "MSG":
                if key != -1:
                    self.cache.modal_state = None
            
            # Settings mode
            elif self.cache.settings_mode:
                self._handle_settings_input(key)
            
            # Theme mode
            elif self.cache.theme_mode:
                self._handle_theme_input(key)
            
            # Normal mode
            else:
                self._handle_normal_input(key)
        except Exception as e:
            self._log.debug(f"Input handling error: {e}")
    
    def _handle_normal_input(self, key: int):
        """Handle input in normal mode with focus-aware navigation - Generated by GitHub Copilot"""
        prev_selected_idx = self.cache.selected_idx

        if key in (ord('q'), ord('Q'), 27):  # q or ESC
            self.running = False
            self.cache.running = False
        
        # Tab to cycle focus between sections - allows targeted scrolling
        elif key == 9:  # TAB
            self._cycle_focus()
        elif key == curses.KEY_BTAB:  # Shift+Tab
            self._cycle_focus_reverse()
        
        # Navigation - depends on focused section
        elif key == curses.KEY_UP:
            if self.cache.focused_section == "containers":
                if self.cache.containers:
                    self.cache.selected_idx = max(0, self.cache.selected_idx - 1)
                    self._sync_container_scroll_to_selection()
                else:
                    self.cache.selected_idx = 0
            else:
                # Scroll up in focused section
                offset = self.cache.scroll_offsets.get(self.cache.focused_section, 0)
                self.cache.scroll_offsets[self.cache.focused_section] = max(0, offset - 1)
        elif key == curses.KEY_DOWN:
            if self.cache.focused_section == "containers":
                if self.cache.containers:
                    self.cache.selected_idx = min(len(self.cache.containers) - 1, self.cache.selected_idx + 1)
                    self._sync_container_scroll_to_selection()
                else:
                    self.cache.selected_idx = 0
            else:
                # Scroll down in focused section
                self._scroll_focused_section(1)
        elif key == curses.KEY_PPAGE:
            # Page Up
            if self.cache.focused_section == "containers":
                page_size = self._get_section_page_size("containers")
                if self.cache.containers:
                    self.cache.selected_idx = max(0, self.cache.selected_idx - page_size)
                    self._sync_container_scroll_to_selection()
            else:
                self._scroll_focused_section(-self._get_section_page_size(self.cache.focused_section))
        elif key == curses.KEY_NPAGE:
            # Page Down
            if self.cache.focused_section == "containers":
                page_size = self._get_section_page_size("containers")
                if self.cache.containers:
                    self.cache.selected_idx = min(len(self.cache.containers) - 1, self.cache.selected_idx + page_size)
                    self._sync_container_scroll_to_selection()
            else:
                self._scroll_focused_section(self._get_section_page_size(self.cache.focused_section))
        elif key == curses.KEY_HOME:
            # Jump to start of focused section
            if self.cache.focused_section == "containers":
                self.cache.selected_idx = 0
                self.cache.scroll_offsets["containers"] = 0
            else:
                self.cache.scroll_offsets[self.cache.focused_section] = 0
        elif key == curses.KEY_END:
            # Jump to end of focused section
            if self.cache.focused_section == "containers":
                if self.cache.containers:
                    self.cache.selected_idx = len(self.cache.containers) - 1
                    self._sync_container_scroll_to_selection()
            else:
                section_name = self.cache.focused_section
                self.cache.scroll_offsets[section_name] = self._get_section_max_offset(section_name)
        
        # Container actions
        elif key == 10:  # ENTER
            if self.cache.containers:
                self.cache.selected_idx = min(self.cache.selected_idx, len(self.cache.containers) - 1)
                container = self.cache.containers[self.cache.selected_idx]
                self.cache.modal_target_id = container.id
                self.cache.modal_target_name = container.name
                self.cache.menu_cursor = 0
                self.cache.modal_state = "MENU"
        
        # Pause/Play
        elif key in (ord('p'), ord('P')):
            self.cache.paused = not self.cache.paused
        
        # Toggle sections
        elif key == ord('1'):
            self.cache.show_sections['containers'] = not self.cache.show_sections['containers']
        elif key == ord('2'):
            self.cache.show_sections['logs'] = not self.cache.show_sections['logs']
        
        # Theme selection
        elif key in (ord('t'), ord('T')):
            self.cache.theme_mode = True
            self.cache.worker_paused = True
            self._theme_before_preview = self.config.selected_theme
            try:
                self.cache.theme_cursor = THEME_NAMES.index(self.config.selected_theme)
            except ValueError:
                self.cache.theme_cursor = 0
        
        # Settings
        elif key in (ord('s'), ord('S')):
            self.cache.settings_mode = True
            self.cache.worker_paused = True
            self.cache.settings_cursor = 0

        # Auto-switch logs panel when selected container changes
        if self.cache.containers:
            self.cache.selected_idx = max(0, min(self.cache.selected_idx, len(self.cache.containers) - 1))
            if self.cache.selected_idx != prev_selected_idx or not self.cache.active_logs_container:
                self._set_active_logs_container_from_selection()

    def _set_active_logs_container_from_selection(self) -> None:
        """Set active logs container to current selection and reset log view - Generated by GitHub Copilot"""
        if not self.cache.containers:
            self.cache.active_logs_container = ""
            self.cache.logs = []
            self.cache.scroll_offsets['logs'] = 0
            return

        selected = self.cache.containers[self.cache.selected_idx]
        selected_name = selected.name
        if self.cache.active_logs_container != selected_name:
            self.cache.active_logs_container = selected_name
            self.cache.logs = []
            self.cache.scroll_offsets['logs'] = 0

    def _get_section_page_size(self, section_name: str) -> int:
        """Return page size for fast scrolling in a section - Generated by GitHub Copilot"""
        section_height = self.cache.section_heights.get(section_name, 6)
        return max(1, section_height - 2)

    def _get_section_max_offset(self, section_name: str) -> int:
        """Return max scroll offset for a section - Generated by GitHub Copilot"""
        content_height = self.cache.section_content_heights.get(section_name, 0)
        viewport_height = self._get_section_viewport_rows(section_name)
        return max(0, content_height - viewport_height)

    def _get_section_viewport_rows(self, section_name: str) -> int:
        """Return visible content rows for a section - Generated by GitHub Copilot"""
        section_height = self.cache.section_heights.get(section_name, 5)
        if section_name == "containers":
            return max(1, section_height - 3)
        return max(1, section_height - 2)

    def _scroll_focused_section(self, delta: int) -> None:
        """Scroll focused section by delta lines with clamping - Generated by GitHub Copilot"""
        section_name = self.cache.focused_section
        offset = self.cache.scroll_offsets.get(section_name, 0)
        max_offset = self._get_section_max_offset(section_name)
        self.cache.scroll_offsets[section_name] = min(max(0, offset + delta), max_offset)

    def _sync_container_scroll_to_selection(self) -> None:
        """Keep selected container visible in viewport - Generated by GitHub Copilot"""
        viewport_rows = self._get_section_viewport_rows("containers")
        offset = self.cache.scroll_offsets.get("containers", 0)
        selected = self.cache.selected_idx

        if selected < offset:
            offset = selected
        elif selected >= offset + viewport_rows:
            offset = selected - viewport_rows + 1

        max_offset = max(0, len(self.cache.containers) - viewport_rows)
        self.cache.scroll_offsets["containers"] = min(max(0, offset), max_offset)
    
    def _handle_menu_input(self, key: int):
        """Handle input in cursor-driven container menu - Generated by GitHub Copilot"""
        menu_actions = self._get_menu_actions()
        max_idx = max(0, len(menu_actions) - 1)

        if key == 27:  # ESC
            self.cache.modal_state = None
            return
        elif key == curses.KEY_UP:
            self.cache.menu_cursor = max(0, self.cache.menu_cursor - 1)
            return
        elif key == curses.KEY_DOWN:
            self.cache.menu_cursor = min(max_idx, self.cache.menu_cursor + 1)
            return
        elif key == 10:  # ENTER selects current action
            selected_action = menu_actions[self.cache.menu_cursor]["id"]
            if selected_action == "cancel":
                self.cache.modal_state = None
                return

            self.cache.confirm_action = selected_action
            self.cache.confirm_cursor = 0  # 0=Yes, 1=No
            self.cache.modal_state = "CONFIRM_ACTION"
    
    def _handle_confirm_input(self, key: int):
        """Handle confirmation dialogs for menu actions - Generated by GitHub Copilot"""
        if self.cache.modal_state == "CONFIRM_ACTION":
            if key in (curses.KEY_LEFT, curses.KEY_UP, 9):  # Left/Up/Tab -> Yes
                self.cache.confirm_cursor = 0
            elif key in (curses.KEY_RIGHT, curses.KEY_DOWN):  # Right/Down -> No
                self.cache.confirm_cursor = 1
            elif key in (ord('y'), ord('Y')):
                self._execute_confirmed_menu_action()
            elif key == 10:  # ENTER on selected Yes/No
                if self.cache.confirm_cursor == 0:
                    self._execute_confirmed_menu_action()
                else:
                    self.cache.modal_state = "MENU"
            elif key in (ord('n'), ord('N'), 27):  # n or ESC
                self.cache.modal_state = "MENU"
            return

        action_map = {
            "CONFIRM_STOP": "stop",
            "CONFIRM_DELETE": "rm",
            "CONFIRM_RESTART": "restart"
        }
        
        if key in (ord('y'), ord('Y')):
            modal_state = self.cache.modal_state or ""
            action = action_map.get(modal_state, "")
            if action:
                self._execute_action(action)
        elif key in (ord('n'), ord('N'), 27):  # n or ESC
            self.cache.modal_state = None

    def _get_menu_actions(self) -> list:
        """Return menu actions in display order - Generated by GitHub Copilot"""
        return [
            {"id": "start", "label": "Start", "color": 2},
            {"id": "stop", "label": "Stop", "color": 3},
            {"id": "restart", "label": "Restart", "color": 4},
            {"id": "update", "label": "Update", "color": 6},
            {"id": "delete", "label": "Delete", "color": 3},
            {"id": "cancel", "label": "Cancel", "color": 4},
        ]

    def _execute_confirmed_menu_action(self) -> None:
        """Execute action confirmed by yes/no dialog - Generated by GitHub Copilot"""
        action = self.cache.confirm_action
        self.cache.confirm_action = ""

        if action == "start":
            self._execute_action("start")
        elif action == "stop":
            self._execute_action("stop")
        elif action == "restart":
            self._execute_action("restart")
        elif action == "update":
            self._execute_update_action()
        elif action == "delete":
            self._execute_action("rm")
        else:
            self.cache.modal_state = "MENU"

    def _open_inspect_modal(self) -> None:
        """Open inspect modal with live docker inspect output - Generated by GitHub Copilot"""
        if not self.cache.containers or self.cache.selected_idx >= len(self.cache.containers):
            self.cache.modal_msg = "No container selected"
            self.cache.modal_state = "MSG"
            return

        container = self.cache.containers[self.cache.selected_idx]

        if not self.loop or self.loop.is_closed():
            # Fallback to cached data if event loop unavailable
            self.cache.modal_msg = (
                f"ID: {container.id}\n"
                f"Name: {container.name}\n"
                f"Image: {container.image}\n"
                f"Status: {container.status}\n"
                f"Ports: {container.ports or 'N/A'}\n"
                f"Command: {container.command or 'N/A'}"
            )
            self.cache.modal_state = "INSPECT"
            return

        self.cache.modal_msg = f"Loading inspect for {container.display_name}..."
        self.cache.modal_state = "MSG"

        async def fetch_inspect():
            try:
                inspect_output = await self.executor.run([
                    "docker", "inspect", container.id
                ])

                if inspect_output and inspect_output.strip():
                    self.cache.modal_msg = inspect_output
                else:
                    self.cache.modal_msg = "No inspect data returned"
                self.cache.modal_state = "INSPECT"
            except Exception as e:
                self.cache.modal_msg = f"Inspect failed: {str(e)}"
                self.cache.modal_state = "MSG"

        try:
            asyncio.run_coroutine_threadsafe(fetch_inspect(), self.loop)
        except Exception as e:
            self.cache.modal_msg = f"Failed to schedule inspect: {str(e)}"
            self.cache.modal_state = "MSG"
    
    def _execute_action(self, action: str):
        """Execute Docker action asynchronously - Generated by GitHub Copilot"""
        if not self.loop or self.loop.is_closed():
            self.cache.modal_msg = "Event loop not available"
            self.cache.modal_state = "MSG"
            return
        
        # Show status message
        self.cache.modal_msg = f"Executing {action}..."
        self.cache.modal_state = "MSG"
        
        # Schedule async operation on worker loop - Generated by GitHub Copilot
        async def do_action():
            try:
                result = await perform_docker_action(
                    self.executor,
                    self.cache.modal_target_id,
                    action
                )
                self.cache.modal_msg = result
                # Keep message visible for 3 seconds
                self.cache.msg_timer = time.time() + 3.0
            except Exception as e:
                self.cache.modal_msg = f"Error: {str(e)}"
        
        # Queue the task on the worker's event loop
        try:
            asyncio.run_coroutine_threadsafe(do_action(), self.loop)
        except Exception as e:
            self.cache.modal_msg = f"Failed to schedule action: {str(e)}"
    
    def _execute_update_action(self):
        """Execute container update with :latest image - Generated by GitHub Copilot"""
        if not self.loop or self.loop.is_closed():
            self.cache.modal_msg = "Event loop not available"
            self.cache.modal_state = "MSG"
            return
        
        # Get container info
        if not self.cache.containers or self.cache.selected_idx >= len(self.cache.containers):
            return
        
        container = self.cache.containers[self.cache.selected_idx]
        self.cache.modal_msg = f"Checking for updates on {container.display_name}..."
        self.cache.modal_state = "MSG"
        
        # Schedule async update check and deploy - Generated by GitHub Copilot
        async def do_update():
            try:
                from docker_worker import check_container_for_updates, update_container_with_latest
                
                # Check for updates
                update_info = await check_container_for_updates(
                    self.executor,
                    container.id,
                    container.image
                )
                
                if update_info['error']:
                    self.cache.modal_msg = f"‚úó Error checking updates: {update_info['error']}"
                elif update_info['has_update']:
                    self.cache.modal_msg = f"üîÑ Updating {container.display_name} to :latest..."
                    result = await update_container_with_latest(
                        self.executor,
                        container.id,
                        container.image
                    )
                    self.cache.modal_msg = result
                else:
                    self.cache.modal_msg = f"‚úì {container.display_name} is already on :latest"
                
                # Keep message visible for 4 seconds
                self.cache.msg_timer = time.time() + 4.0
            except Exception as e:
                self.cache.modal_msg = f"‚úó Update error: {str(e)}"
                self.cache.msg_timer = time.time() + 3.0
        
        # Queue the task on the worker's event loop
        try:
            asyncio.run_coroutine_threadsafe(do_update(), self.loop)
        except Exception as e:
            self.cache.modal_msg = f"Failed to schedule update: {str(e)}"
    
    def _handle_settings_input(self, key: int):
        """Handle settings mode input - Generated by GitHub Copilot"""
        if key == 27:  # ESC
            self.cache.settings_mode = False
            self.cache.worker_paused = False
            return
        
        if key == curses.KEY_UP:
            self.cache.settings_cursor = max(0, self.cache.settings_cursor - 1)
        elif key == curses.KEY_DOWN:
            self.cache.settings_cursor = min(len(EDITABLE_SETTINGS) - 1, self.cache.settings_cursor + 1)
        elif key in (ord('+'), ord('=')):
            self._adjust_setting(1)
        elif key in (ord('-'), ord('_')):
            self._adjust_setting(-1)
    
    def _adjust_setting(self, delta: int):
        """Adjust current setting value"""
        if 0 <= self.cache.settings_cursor < len(EDITABLE_SETTINGS):
            setting = EDITABLE_SETTINGS[self.cache.settings_cursor]
            current = getattr(self.config, setting.key)
            
            if setting.stype == "bool":
                new_value = not current
            elif setting.stype == "int":
                new_value = current + int(setting.step * delta)
            elif setting.stype == "float":
                new_value = current + (setting.step * delta)
            else:
                return
            
            # Clamp to range
            new_value = max(setting.smin, min(setting.smax, new_value))
            self.config.set_setting(setting.key, new_value)
            self.config.save_settings()
    
    def _handle_theme_input(self, key: int):
        """Handle theme selection input with confirmation - Generated by GitHub Copilot"""
        if key == 27:  # ESC
            from docker_themes import init_curses_colors
            prev_theme = self._theme_before_preview
            if prev_theme not in THEME_NAMES:
                prev_theme = "Default"
            self.config.selected_theme = prev_theme
            init_curses_colors(prev_theme)
            self.cache.theme_mode = False
            self.cache.worker_paused = False
            self.cache.modal_state = None
            return
        
        if key == curses.KEY_UP:
            self.cache.theme_cursor = max(0, self.cache.theme_cursor - 1)
        elif key == curses.KEY_DOWN:
            self.cache.theme_cursor = min(len(THEME_NAMES) - 1, self.cache.theme_cursor + 1)
        elif key == 10:  # ENTER - Show confirmation dialog
            # Switch to confirmation state
            from docker_themes import init_curses_colors
            selected_theme = THEME_NAMES[self.cache.theme_cursor]
            self._theme_before_preview = self.config.selected_theme
            # Temporarily apply theme to preview
            self.config.selected_theme = selected_theme
            init_curses_colors(selected_theme)
            # Show confirmation modal
            self.cache.modal_state = "SET_THEME_DEFAULT"
    
    def _handle_theme_confirm_input(self, key: int):
        """Handle theme confirmation input - Generated by GitHub Copilot"""
        if key in (10, 13, ord('y'), ord('Y')):
            # Save as default and exit
            self.config.save_settings()
            self.cache.theme_mode = False
            self.cache.worker_paused = False
            self.cache.modal_state = None
        elif key in (ord('n'), ord('N')):
            # Keep previewed theme for this session, but do not persist
            self.cache.theme_mode = False
            self.cache.worker_paused = False
            self.cache.modal_state = None
        elif key == 27:  # ESC
            # Cancel and revert
            from docker_themes import init_curses_colors
            prev_theme = self._theme_before_preview
            if prev_theme not in THEME_NAMES:
                prev_theme = "Default"
            self.config.selected_theme = prev_theme
            init_curses_colors(prev_theme)
            self.cache.theme_mode = False
            self.cache.worker_paused = False
            self.cache.modal_state = None
    
    def _display_logs(self):
        """Display container logs in modal - Generated by GitHub Copilot"""
        if not self.cache.containers or self.cache.selected_idx >= len(self.cache.containers):
            return
        
        container = self.cache.containers[self.cache.selected_idx]
        self.cache.modal_msg = f"Loading logs for {container.display_name}..."
        self.cache.modal_state = "MSG"
        
        # Schedule async log fetch on worker eventloop
        async def fetch_logs():
            try:
                # Get recent logs from the container
                if hasattr(self, 'executor') and self.executor:
                    logs = await self.executor.run(
                        ["docker", "logs", "--tail", "50", "--timestamps", container.id]
                    )
                    # Store in cache for display
                    self.cache.modal_msg = logs if logs else "No logs available"
                else:
                    self.cache.modal_msg = "Cannot fetch logs: executor not available"
            except Exception as e:
                self.cache.modal_msg = f"Error loading logs: {str(e)}"
        
        # Queue the task
        try:
            if self.loop and not self.loop.is_closed():
                asyncio.run_coroutine_threadsafe(fetch_logs(), self.loop)
        except Exception as e:
            self.cache.modal_msg = f"Failed to fetch logs: {str(e)}"
    
    def _cycle_focus(self):
        """Cycle focus between visible sections - Generated by GitHub Copilot"""
        # Get list of visible sections in priority order
        visible_sections = [s for s in self.cache.section_priority 
                           if self.cache.show_sections.get(s, False)]
        
        if not visible_sections:
            return
        
        # Find current focus index
        try:
            current_idx = visible_sections.index(self.cache.focused_section)
        except ValueError:
            current_idx = 0
        
        # Move to next section (cycle back to start)
        next_idx = (current_idx + 1) % len(visible_sections)
        self.cache.focused_section = visible_sections[next_idx]
        self.cache.scroll_offsets[self.cache.focused_section] = 0  # Reset scroll on focus change

    def _cycle_focus_reverse(self):
        """Cycle focus backward between visible sections - Generated by GitHub Copilot"""
        visible_sections = [s for s in self.cache.section_priority
                            if self.cache.show_sections.get(s, False)]

        if not visible_sections:
            return

        try:
            current_idx = visible_sections.index(self.cache.focused_section)
        except ValueError:
            current_idx = 0

        prev_idx = (current_idx - 1) % len(visible_sections)
        self.cache.focused_section = visible_sections[prev_idx]
        self.cache.scroll_offsets[self.cache.focused_section] = 0
    
    def _cleanup(self):
        """Cleanup on exit with proper async shutdown - Generated by GitHub Copilot"""
        try:
            self.cache.running = False
            if self.worker_thread and self.worker_thread.is_alive():
                self.worker_thread.join(timeout=2.0)
            
            self.config.save_settings()
            self._log.info("Application shutdown complete")
        except Exception as e:
            self._log.error(f"Cleanup error: {e}")


def main():
    """Entry point for the application"""
    # Check Docker permissions first - Generated by GitHub Copilot
    docker_ok, docker_msg = check_docker_permissions()
    
    if not docker_ok:
        print("\n" + "=" * 60)
        print("üê≥ Docker Monitor v2.0")
        print("=" * 60)
        print(f"\n‚úó Docker Access Issue: {docker_msg}")
        print("\nPossible solutions:")
        print("1. Make sure Docker is installed: docker --version")
        print("2. Start Docker daemon: sudo systemctl start docker")
        print("3. Check your Docker group membership: id -nG")
        print("4. Add yourself to docker group: sudo usermod -aG docker $USER")
        print("   (Then log out and log back in)")
        print("\nIf installed via installer.sh, re-run it to diagnose issues.")
        print("=" * 60 + "\n")
        sys.exit(1)
    
    # Setup logging
    log_file = '/tmp/docker_monitor.log'
    
    # Create or rotate log file if write fails - Green Software temp file handling
    try:
        # Try to open existing file for writing
        with open(log_file, 'a') as f:
            f.write("")  # Test write
    except (IOError, OSError):
        # If write fails, create a new numbered file
        import time
        timestamp = int(time.time())
        log_file = f'/tmp/docker_monitor_{timestamp}.log'
    
    logging.basicConfig(
        filename=log_file,
        level=logging.DEBUG,
        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
    )
    log = logging.getLogger(__name__)
    log.info("Starting Docker Monitor v2.0")
    
    def run_app(stdscr):
        """Wrapper for curses"""
        app = DockerMonitor(stdscr)
        app.run()
    
    try:
        curses.wrapper(run_app)
        print("Thank you for using Docker Monitor ‚Äî Davidian-SK")
    except KeyboardInterrupt:
        print("\nThank you for using Docker Monitor ‚Äî Davidian-SK")
        sys.exit(0)
    except Exception as e:
        print(f"Fatal error: {e}")
        sys.exit(1)


if __name__ == "__main__":
    main()
