"""
Docker Task Manager

Manages async tasks with deduplication and status tracking.
Generated by GitHub Copilot - Inspired by lazydocker taskmanagement
"""

import asyncio
from typing import Dict, Callable, Optional, Union, Any
from dataclasses import dataclass, field
from enum import Enum
import time
import uuid


class TaskStatus(Enum):
    """Task execution status"""
    PENDING = "pending"
    RUNNING = "running"
    COMPLETED = "completed"
    FAILED = "failed"
    CANCELLED = "cancelled"


@dataclass
class Task:
    """Represents a scheduled Docker operation"""
    id: str
    name: str
    operation: Callable
    status: TaskStatus = TaskStatus.PENDING
    result: Any = None
    error: Optional[str] = None
    created_at: float = field(default_factory=time.time)
    started_at: Optional[float] = None
    completed_at: Optional[float] = None
    _task: Optional[asyncio.Task] = None
    
    @property
    def duration(self) -> Optional[float]:
        """Time taken to complete"""
        if self.completed_at and self.started_at:
            return self.completed_at - self.started_at
        return None
    
    @property
    def is_running(self) -> bool:
        """Check if task is currently running"""
        return self.status == TaskStatus.RUNNING
    
    @property
    def is_done(self) -> bool:
        """Check if task is finished"""
        return self.status in (TaskStatus.COMPLETED, TaskStatus.FAILED, TaskStatus.CANCELLED)


class TaskManager:
    """Queue and deduplicate Docker operations"""
    
    def __init__(self):
        self._tasks: Dict[str, Task] = {}
        self._in_flight: Dict[str, asyncio.Task] = {}
        self._history: Dict[str, Task] = {}
        self._max_history = 100
    
    async def queue_operation(self, name: str, operation: Callable, 
                             deduplicate: bool = True) -> Task:
        """
        Queue a Docker operation.
        
        Args:
            name: Operation name (used as dedup key)
            operation: Async callable to execute
            deduplicate: Skip if same operation already running
        
        Returns:
            Task object
        """
        # Check if already running (deduplication)
        if deduplicate and name in self._in_flight:
            existing = self._tasks[name]
            if not existing.is_done:
                return existing
        
        # Create new task
        task_id = str(uuid.uuid4())[:8]
        task = Task(id=task_id, name=name, operation=operation)
        self._tasks[name] = task
        
        # Schedule execution
        asyncio.create_task(self._execute_task(name, task))
        
        return task
    
    async def _execute_task(self, key: str, task: Task) -> None:
        """Execute task with status tracking"""
        try:
            task.status = TaskStatus.RUNNING
            task.started_at = time.time()
            
            # Run operation
            result = await task.operation()
            
            task.result = result
            task.status = TaskStatus.COMPLETED
            task.completed_at = time.time()
            
        except asyncio.CancelledError:
            task.status = TaskStatus.CANCELLED
            task.completed_at = time.time()
            
        except Exception as e:
            task.error = str(e)
            task.status = TaskStatus.FAILED
            task.completed_at = time.time()
        
        finally:
            # Move to history
            self._history[task.id] = task
            if len(self._history) > self._max_history:
                # Remove oldest
                oldest = min(self._history.items(), key=lambda x: x[1].created_at)
                del self._history[oldest[0]]
    
    async def get_task(self, task_id: str) -> Optional[Task]:
        """Get task by ID"""
        # Check active tasks
        for task in self._tasks.values():
            if task.id == task_id:
                return task
        
        # Check history
        return self._history.get(task_id)
    
    async def get_task_status(self, name: str) -> TaskStatus:
        """Get status of named operation"""
        if name in self._tasks:
            return self._tasks[name].status
        return TaskStatus.PENDING
    
    async def get_running_tasks(self) -> list[Task]:
        """Get all currently running tasks"""
        return [t for t in self._tasks.values() if t.is_running]
    
    async def get_all_tasks(self) -> list[Task]:
        """Get all tasks (active + history)"""
        all_tasks = list(self._tasks.values()) + list(self._history.values())
        return sorted(all_tasks, key=lambda t: t.created_at, reverse=True)
    
    async def cancel_task(self, task_id: str) -> bool:
        """Cancel a task if running"""
        for task in self._tasks.values():
            if task.id == task_id and task.is_running:
                if task._task:
                    task._task.cancel()
                task.status = TaskStatus.CANCELLED
                task.completed_at = time.time()
                return True
        return False
    
    async def wait_for_task(self, task_id: str, timeout: Optional[float] = None) -> Optional[Any]:
        """
        Wait for task to complete and return result.
        
        Args:
            task_id: ID of task to wait for
            timeout: Max seconds to wait
        
        Returns:
            Task result or None if timeout/failed
        """
        start = time.time()
        
        while True:
            task = await self.get_task(task_id)
            if not task:
                return None
            
            if task.is_done:
                return task.result if task.status == TaskStatus.COMPLETED else None
            
            if timeout and (time.time() - start) > timeout:
                return None
            
            await asyncio.sleep(0.1)
    
    async def clear_history(self) -> int:
        """Clear task history and return count"""
        count = len(self._history)
        self._history.clear()
        return count


class BatchTaskRunner:
    """Run multiple tasks with progress tracking"""
    
    def __init__(self, task_manager: TaskManager, concurrency: int = 3):
        self.task_manager = task_manager
        self.concurrency = concurrency
    
    async def run_batch(self, operations: Dict[str, Callable]) -> Dict[str, Union[Any, str]]:
        """
        Run multiple operations with concurrency limit.
        
        Args:
            operations: Dict of name -> operation callable
        
        Returns:
            Dict of name -> result or error message
        """
        semaphore = asyncio.Semaphore(self.concurrency)
        results = {}
        
        async def _run_with_limit(name: str, op: Callable):
            async with semaphore:
                task = await self.task_manager.queue_operation(name, op, deduplicate=False)
                result = await self.task_manager.wait_for_task(task.id)
                results[name] = result if result is not None else task.error or "Unknown error"
        
        # Schedule all operations
        tasks = [
            asyncio.create_task(_run_with_limit(name, op))
            for name, op in operations.items()
        ]
        
        # Wait for all
        await asyncio.gather(*tasks, return_exceptions=True)
        
        return results
