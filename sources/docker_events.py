"""
Docker Events Monitoring

Real-time Docker events API integration for reactive updates.
Generated by GitHub Copilot - Inspired by lazydocker event handling
"""

import asyncio
import json
from typing import Callable, Optional, Dict, Any
from datetime import datetime
from dataclasses import dataclass
from enum import Enum


class EventType(Enum):
    """Docker event types"""
    CONTAINER = "container"
    IMAGE = "image"
    NETWORK = "network"
    VOLUME = "volume"
    SYSTEM = "system"
    UNKNOWN = "unknown"


class EventAction(Enum):
    """Common Docker event actions"""
    START = "start"
    STOP = "stop"
    DIE = "die"
    CREATE = "create"
    DESTROY = "destroy"
    REMOVE = "remove"
    PAUSE = "pause"
    UNPAUSE = "unpause"
    BUILD = "build"
    PULL = "pull"
    PUSH = "push"
    TAG = "tag"
    UNTAG = "untag"
    CONNECT = "connect"
    DISCONNECT = "disconnect"
    MOUNT = "mount"
    UNMOUNT = "unmount"


@dataclass
class DockerEvent:
    """Represents a Docker event"""
    type: EventType
    action: str
    actor_id: str
    actor_attributes: Dict[str, Any]
    timestamp: datetime
    raw_event: Dict[str, Any]
    
    @property
    def container_id(self) -> Optional[str]:
        """Get container ID if applicable"""
        if self.type == EventType.CONTAINER:
            return self.actor_id
        return None
    
    @property
    def image_name(self) -> Optional[str]:
        """Get image name if applicable"""
        if self.type == EventType.IMAGE:
            return self.actor_attributes.get("name")
        return None


class DockerEventMonitor:
    """Listen to Docker events API in real-time"""
    
    def __init__(self):
        self._handlers: Dict[str, list[Callable]] = {}
        self._monitoring = False
        self._event_task: Optional[asyncio.Task] = None
    
    def subscribe(self, event_filter: str, handler: Callable) -> None:
        """
        Subscribe to events.
        
        Filters:
            "container:start" - container started
            "container:stop" - container stopped
            "container:*" - all container events
            "image:*" - all image events
            "*" - all events
        """
        if event_filter not in self._handlers:
            self._handlers[event_filter] = []
        self._handlers[event_filter].append(handler)
    
    def unsubscribe(self, event_filter: str, handler: Callable) -> None:
        """Unsubscribe from events"""
        if event_filter in self._handlers:
            self._handlers[event_filter] = [
                h for h in self._handlers[event_filter] if h != handler
            ]
    
    async def start_monitoring(self) -> None:
        """Start listening to Docker events"""
        if self._monitoring:
            return
        
        self._monitoring = True
        self._event_task = asyncio.create_task(self._watch_events())
    
    async def stop_monitoring(self) -> None:
        """Stop listening to Docker events"""
        self._monitoring = False
        if self._event_task:
            try:
                self._event_task.cancel()
            except RuntimeError:
                # Loop already closed
                self._event_task = None
                return
            try:
                await self._event_task
            except asyncio.CancelledError:
                pass
            except RuntimeError:
                # Loop already closed
                pass
            finally:
                self._event_task = None
    
    async def _watch_events(self) -> None:
        """Internal: Stream Docker events - Generated by GitHub Copilot
        
        Security: Subprocess is killed on monitoring stop to prevent orphaned processes.
        """
        proc = None
        try:
            proc = await asyncio.create_subprocess_exec(
                "docker", "events", "--format", "json",
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            
            while self._monitoring and proc.stdout:
                line = await proc.stdout.readline()
                if not line:
                    break
                
                try:
                    raw_event = json.loads(line.decode('utf-8', errors='ignore'))
                    event = self._parse_event(raw_event)
                    
                    if event:
                        await self._dispatch_event(event)
                
                except (json.JSONDecodeError, Exception):
                    continue
        
        except asyncio.CancelledError:
            pass
        except Exception:
            pass
        finally:
            if proc is not None:
                try:
                    proc.kill()
                    await proc.wait()
                except ProcessLookupError:
                    pass
                except Exception:
                    pass
    
    def _parse_event(self, raw: Dict[str, Any]) -> Optional[DockerEvent]:
        """Parse raw Docker event"""
        try:
            event_type_str = raw.get("Type", "unknown")
            event_type = EventType[event_type_str.upper()] if event_type_str in [e.value for e in EventType] else EventType.UNKNOWN
            
            # Handle type lookup
            for et in EventType:
                if et.value == event_type_str:
                    event_type = et
                    break
            
            actor = raw.get("Actor", {})
            
            return DockerEvent(
                type=event_type,
                action=raw.get("Action", "unknown"),
                actor_id=actor.get("ID", "unknown"),
                actor_attributes=actor.get("Attributes", {}),
                timestamp=datetime.fromtimestamp(raw.get("time", 0)),
                raw_event=raw
            )
        except Exception:
            return None
    
    async def _dispatch_event(self, event: DockerEvent) -> None:
        """Dispatch event to handlers"""
        # Try specific handlers
        filter_key = f"{event.type.value}:{event.action}"
        
        if filter_key in self._handlers:
            for handler in self._handlers[filter_key]:
                try:
                    await self._call_handler(handler, event)
                except Exception:
                    pass
        
        # Try wildcard type handlers
        type_wildcard = f"{event.type.value}:*"
        if type_wildcard in self._handlers:
            for handler in self._handlers[type_wildcard]:
                try:
                    await self._call_handler(handler, event)
                except Exception:
                    pass
        
        # Try catch-all handlers
        if "*" in self._handlers:
            for handler in self._handlers["*"]:
                try:
                    await self._call_handler(handler, event)
                except Exception:
                    pass
    
    async def _call_handler(self, handler: Callable, event: DockerEvent) -> None:
        """Call handler (support both sync and async)"""
        if asyncio.iscoroutinefunction(handler):
            await handler(event)
        else:
            handler(event)


class EventReactors:
    """Predefined reactive handlers for common events"""
    
    @staticmethod
    def container_state_change(callback: Callable) -> Callable:
        """React to container state changes (start/stop/die)"""
        async def handler(event: DockerEvent):
            if event.type == EventType.CONTAINER and event.action in ["start", "stop", "die", "pause", "unpause"]:
                await callback(event)
        return handler
    
    @staticmethod
    def image_change(callback: Callable) -> Callable:
        """React to image changes (build/pull/remove)"""
        async def handler(event: DockerEvent):
            if event.type == EventType.IMAGE and event.action in ["build", "pull", "remove"]:
                await callback(event)
        return handler
    
    @staticmethod
    def network_change(callback: Callable) -> Callable:
        """React to network changes"""
        async def handler(event: DockerEvent):
            if event.type == EventType.NETWORK and event.action in ["connect", "disconnect", "create", "destroy"]:
                await callback(event)
        return handler
    
    @staticmethod
    def volume_change(callback: Callable) -> Callable:
        """React to volume changes"""
        async def handler(event: DockerEvent):
            if event.type == EventType.VOLUME and event.action in ["create", "destroy", "mount", "unmount"]:
                await callback(event)
        return handler


class EventFilter:
    """Build complex event filters"""
    
    def __init__(self):
        self.filters: Dict[str, Any] = {}
    
    def container_id(self, container_id: str) -> "EventFilter":
        """Filter by container ID"""
        self.filters["container_id"] = container_id
        return self
    
    def image_name(self, image_name: str) -> "EventFilter":
        """Filter by image name"""
        self.filters["image_name"] = image_name
        return self
    
    def action(self, action: str) -> "EventFilter":
        """Filter by action"""
        self.filters["action"] = action
        return self
    
    def event_type(self, event_type: str) -> "EventFilter":
        """Filter by event type"""
        self.filters["type"] = event_type
        return self
    
    def matches(self, event: DockerEvent) -> bool:
        """Check if event matches filter"""
        if "container_id" in self.filters:
            if event.container_id != self.filters["container_id"]:
                return False
        
        if "image_name" in self.filters:
            if event.image_name != self.filters["image_name"]:
                return False
        
        if "action" in self.filters:
            if event.action != self.filters["action"]:
                return False
        
        if "type" in self.filters:
            if event.type.value != self.filters["type"]:
                return False
        
        return True


class EventBuffer:
    """Buffer recent events for analysis"""
    
    def __init__(self, max_size: int = 1000):
        self.events: list[DockerEvent] = []
        self.max_size = max_size
    
    def add_event(self, event: DockerEvent) -> None:
        """Add event to buffer"""
        self.events.append(event)
        if len(self.events) > self.max_size:
            self.events.pop(0)
    
    def get_events_for_container(self, container_id: str) -> list[DockerEvent]:
        """Get all events for container"""
        return [e for e in self.events if e.container_id == container_id]
    
    def get_recent_events(self, limit: int = 50) -> list[DockerEvent]:
        """Get N most recent events"""
        return self.events[-limit:]
    
    def clear(self) -> None:
        """Clear event buffer"""
        self.events.clear()
