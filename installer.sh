#!/usr/bin/env bash
# Docker Monitor installer - by Davidian-SK
# Generated by GithubCopilot
# Installs Docker Monitor to /opt/docker_monitor/ and creates /usr/bin/dstat launcher.

set -euo pipefail

readonly VERSION="2.1"
readonly INSTALL_DIR="/opt/docker_monitor"
readonly LAUNCHER_PATH="/usr/bin/dstat"
readonly REQUIRED_COMMANDS=(tar mktemp chmod rm cat python3 docker)

EXECUTION_DIR="$(pwd -P)"
ARCHIVE_PATH="${EXECUTION_DIR}/docker_monitor.tar.xz"
ARCHIVE_PATH_EXPLICIT="false"
MODE="install"
SHOW_HELP="false"
SUDO_CMD=""
TEMP_DIR=""

# --- Output helpers ---

print_banner() {
  echo "=============================================="
  echo "  Docker Monitor v${VERSION} - Installer"
  echo "  by Davidian-SK"
  echo "=============================================="
  echo ""
}

print_usage() {
  cat <<EOF
Docker Monitor v${VERSION} installer - by Davidian-SK

Usage:
  ./installer.sh [archive_path]
  ./installer.sh --clean-install [archive_path]
  ./installer.sh --purge
  ./installer.sh --help

Options:
  --clean-install  Remove existing install first, then install from archive.
  --purge          Remove ${INSTALL_DIR}/ and ${LAUNCHER_PATH}.
  --help           Show this help message.

Defaults:
  archive_path defaults to ./docker_monitor.tar.xz in the current execution directory.

Notes:
  - Installer auto-installs missing requirements when a supported package manager is available.
  - Install/clean-install aborts if Docker daemon is not active or no running containers are found.
  - Archive must include updated theme modules (docker_main.py, docker_ui.py, docker_themes.py).
  - Supported package managers: apt-get, dnf, yum, zypper, pacman.
EOF
}

print_thank_you() {
  echo ""
  echo "=============================================="
  echo "  Thank you for using Docker Monitor!"
  echo "  Created by Davidian-SK"
  echo "=============================================="
  echo ""
}

# --- Cleanup ---

cleanup() {
  if [[ -n "${TEMP_DIR:-}" && -d "${TEMP_DIR:-}" ]]; then
    rm -rf "${TEMP_DIR}"
  fi
}

trap cleanup EXIT

# --- Argument parsing ---

parse_args() {
  if [[ "$#" -gt 2 ]]; then
    echo "Error: too many arguments."
    print_usage
    exit 1
  fi

  for arg in "$@"; do
    case "${arg}" in
      --help|-h)
        SHOW_HELP="true"
        ;;
      --clean-install)
        if [[ "${MODE}" == "purge" ]]; then
          echo "Error: --clean-install cannot be combined with --purge."
          print_usage
          exit 1
        fi
        MODE="clean-install"
        ;;
      --purge)
        if [[ "${MODE}" == "clean-install" ]]; then
          echo "Error: --purge cannot be combined with --clean-install."
          print_usage
          exit 1
        fi
        MODE="purge"
        ;;
      *)
        if [[ "${MODE}" == "purge" ]]; then
          echo "Error: archive path is not accepted with --purge."
          print_usage
          exit 1
        fi
        if [[ "${SHOW_HELP}" == "true" ]]; then
          echo "Error: archive path is not accepted with --help."
          print_usage
          exit 1
        fi
        ARCHIVE_PATH="${arg}"
        ARCHIVE_PATH_EXPLICIT="true"
        ;;
    esac
  done
}

# --- Precondition checks ---

require_linux() {
  if [[ "$(uname -s)" != "Linux" ]]; then
    echo "Error: installer.sh supports Linux only."
    exit 1
  fi
}

require_sudo_access() {
  if [[ "${EUID}" -eq 0 ]]; then
    SUDO_CMD=""
    return
  fi

  if ! command -v sudo >/dev/null 2>&1; then
    echo "Error: sudo is required to install into ${INSTALL_DIR}/ and ${LAUNCHER_PATH}."
    exit 1
  fi

  if ! sudo -v 2>/dev/null; then
    echo "Error: sudo authentication failed."
    exit 1
  fi

  SUDO_CMD="sudo"
}

# --- Package manager ---

detect_package_manager() {
  local managers=(apt-get dnf yum zypper pacman)
  local mgr
  for mgr in "${managers[@]}"; do
    if command -v "${mgr}" >/dev/null 2>&1; then
      echo "${mgr}"
      return
    fi
  done
  echo ""
}

map_command_to_package() {
  local command_name="$1"
  local manager="$2"

  case "${command_name}" in
    tar)
      echo "tar"
      ;;
    mktemp|chmod|rm|cat)
      echo "coreutils"
      ;;
    python3)
      if [[ "${manager}" == "pacman" ]]; then
        echo "python"
      else
        echo "python3"
      fi
      ;;
    docker)
      if [[ "${manager}" == "apt-get" ]]; then
        echo "docker.io"
      else
        echo "docker"
      fi
      ;;
    *)
      echo "${command_name}"
      ;;
  esac
}

install_packages() {
  local manager="$1"
  shift
  local packages=("$@")

  echo "Installing missing packages via ${manager}: ${packages[*]}"

  case "${manager}" in
    apt-get)
      ${SUDO_CMD} apt-get update -qq
      ${SUDO_CMD} apt-get install -y "${packages[@]}"
      ;;
    dnf)
      ${SUDO_CMD} dnf install -y "${packages[@]}"
      ;;
    yum)
      ${SUDO_CMD} yum install -y "${packages[@]}"
      ;;
    zypper)
      ${SUDO_CMD} zypper --non-interactive install "${packages[@]}"
      ;;
    pacman)
      ${SUDO_CMD} pacman -Sy --noconfirm "${packages[@]}"
      ;;
    *)
      echo "Error: unsupported package manager '${manager}'."
      exit 1
      ;;
  esac
}

ensure_requirements() {
  local missing=()
  local cmd

  for cmd in "${REQUIRED_COMMANDS[@]}"; do
    if ! command -v "${cmd}" >/dev/null 2>&1; then
      missing+=("${cmd}")
    fi
  done

  if [[ "${#missing[@]}" -eq 0 ]]; then
    echo "All requirements satisfied."
    return
  fi

  echo "Missing commands: ${missing[*]}"

  local manager
  manager="$(detect_package_manager)"
  if [[ -z "${manager}" ]]; then
    echo "Error: no supported package manager found to install missing dependencies."
    echo "Install manually: ${missing[*]}"
    exit 1
  fi

  # Map commands to package names and de-duplicate via associative array
  declare -A package_set
  local pkg
  for cmd in "${missing[@]}"; do
    pkg="$(map_command_to_package "${cmd}" "${manager}")"
    package_set["${pkg}"]=1
  done

  install_packages "${manager}" "${!package_set[@]}"

  # Verify all commands are now available
  for cmd in "${REQUIRED_COMMANDS[@]}"; do
    if ! command -v "${cmd}" >/dev/null 2>&1; then
      echo "Error: '${cmd}' is still unavailable after installation attempt."
      exit 1
    fi
  done

  echo "All requirements installed successfully."
}

# --- Docker checks ---

require_docker_in_use() {
  if ! docker info >/dev/null 2>&1; then
    echo "Error: Docker daemon is not reachable."
    echo "Start Docker and retry."
    exit 1
  fi

  local running_count
  running_count="$(docker ps -q 2>/dev/null | wc -l)"
  if [[ "${running_count}" -eq 0 ]]; then
    echo "Error: no running Docker containers found."
    echo "Docker Monitor requires an active Docker environment."
    exit 1
  fi

  echo "Docker is active with ${running_count} running container(s)."
}

# --- Archive validation ---

validate_archive() {
  if [[ ! -f "${ARCHIVE_PATH}" ]]; then
    echo "Error: archive not found at ${ARCHIVE_PATH}"
    if [[ "${ARCHIVE_PATH_EXPLICIT}" != "true" ]]; then
      echo "Expected docker_monitor.tar.xz in: ${EXECUTION_DIR}/"
    fi
    echo "Usage: ./installer.sh [/path/to/docker_monitor.tar.xz]"
    exit 1
  fi

  echo "Archive found: ${ARCHIVE_PATH}"
}

# --- Existing install detection ---

check_existing_install() {
  local found="false"

  if [[ -d "${INSTALL_DIR}" && -f "${INSTALL_DIR}/docker_main.py" ]]; then
    found="true"
  elif [[ -f "${LAUNCHER_PATH}" ]]; then
    found="true"
  fi

  if [[ "${found}" != "true" ]]; then
    return
  fi

  echo "Existing Docker Monitor installation detected at ${INSTALL_DIR}/."

  if [[ ! -t 0 ]]; then
    echo "Error: non-interactive session cannot confirm overwrite."
    echo "Use --clean-install to replace or --purge to remove."
    exit 1
  fi

  local answer
  while true; do
    read -r -p "Choose action — [A]bort or [C]lean install? " answer
    case "${answer}" in
      [Aa]|[Aa][Bb][Oo][Rr][Tt])
        echo "Installation aborted by user."
        print_thank_you
        exit 0
        ;;
      [Cc]|[Cc][Ll][Ee][Aa][Nn]*)
        MODE="clean-install"
        echo "Switching to clean install..."
        return
        ;;
      *)
        echo "Invalid choice. Enter A to abort or C for clean install."
        ;;
    esac
  done
}

# --- Install / Purge ---

install_app() {
  TEMP_DIR="$(mktemp -d)"

  echo "Extracting ${ARCHIVE_PATH}..."
  tar -xJf "${ARCHIVE_PATH}" -C "${TEMP_DIR}"

  local extracted_root="${TEMP_DIR}"
  if [[ -d "${TEMP_DIR}/docker_monitor" ]]; then
    extracted_root="${TEMP_DIR}/docker_monitor"
  fi

  ${SUDO_CMD} mkdir -p "${INSTALL_DIR}"
  ${SUDO_CMD} rm -rf "${INSTALL_DIR:?}/"*
  ${SUDO_CMD} cp -R "${extracted_root}/"* "${INSTALL_DIR}/"

  ${SUDO_CMD} tee "${LAUNCHER_PATH}" >/dev/null <<'LAUNCHER'
#!/usr/bin/env bash
set -euo pipefail
APP_DIR="/opt/docker_monitor"

if [[ ! -f "${APP_DIR}/docker_main.py" ]]; then
  echo "Docker Monitor is not installed correctly at ${APP_DIR}/."
  exit 1
fi

exec python3 "${APP_DIR}/docker_main.py" "$@"
LAUNCHER

  ${SUDO_CMD} chmod 755 "${LAUNCHER_PATH}"

  run_post_install_checks

  echo ""
  echo "Install complete. Run with: dstat"
}

run_post_install_checks() {
  echo "Running post-install verification..."

  local checks_passed="true"

  if [[ ! -f "${INSTALL_DIR}/docker_main.py" ]]; then
    echo "  FAIL: ${INSTALL_DIR}/docker_main.py not found."
    checks_passed="false"
  fi

  if [[ ! -x "${LAUNCHER_PATH}" ]]; then
    echo "  FAIL: ${LAUNCHER_PATH} is not executable."
    checks_passed="false"
  fi

  if ! command -v python3 >/dev/null 2>&1; then
    echo "  FAIL: python3 is not available."
    checks_passed="false"
  fi

  if ! command -v docker >/dev/null 2>&1; then
    echo "  FAIL: docker is not available."
    checks_passed="false"
  fi

  if [[ "${checks_passed}" != "true" ]]; then
    echo "Post-install verification failed."
    exit 1
  fi

  echo "Post-install verification passed."
}

purge_app() {
  echo "Purging Docker Monitor..."

  if [[ -d "${INSTALL_DIR}" ]]; then
    ${SUDO_CMD} rm -rf "${INSTALL_DIR}"
    echo "  Removed ${INSTALL_DIR}/"
  else
    echo "  ${INSTALL_DIR}/ not found (skipped)."
  fi

  if [[ -f "${LAUNCHER_PATH}" ]]; then
    ${SUDO_CMD} rm -f "${LAUNCHER_PATH}"
    echo "  Removed ${LAUNCHER_PATH}"
  else
    echo "  ${LAUNCHER_PATH} not found (skipped)."
  fi

  echo "Purge complete."
}

# === Main entry point ===

parse_args "$@"

# Help is available on any OS — check before require_linux
if [[ "${SHOW_HELP}" == "true" ]]; then
  print_usage
  exit 0
fi

require_linux
print_banner
require_sudo_access

case "${MODE}" in
  purge)
    purge_app
    ;;
  clean-install)
    ensure_requirements
    require_docker_in_use
    validate_archive
    purge_app
    install_app
    ;;
  install)
    check_existing_install
    ensure_requirements
    require_docker_in_use
    validate_archive
    if [[ "${MODE}" == "clean-install" ]]; then
      purge_app
    fi
    install_app
    ;;
esac

print_thank_you
